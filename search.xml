<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《文明之旅》1021-1030年</title>
      <link href="/2025/02/14/wen-ming-zhi-lu-1021-1030-nian/"/>
      <url>/2025/02/14/wen-ming-zhi-lu-1021-1030-nian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>这是一档聚焦中国历史，计划持续二十年制作播出的视频节目，也是一个超长期的文化工程。它将传承《资治通鉴》的中国编年史传统，从公元1000年开讲，一直讲到1912年，每一期节目聚焦于中国历史上的一年。上下913期节目，前后20年的时光，将陪伴和影响不止一代人。</strong></p><hr><h2 id="1021-1030"><a href="#1021-1030" class="headerlink" title="1021~1030"></a>1021~1030</h2><h3 id="1021"><a href="#1021" class="headerlink" title="1021"></a>1021</h3><ul><li>寇准被贬后，实际上是刘皇后和丁谓主持朝政。丁谓是“非典型天才”，很会解决问题。他的聪明不是脑子快，而是看问题的维度高。但是当时人都认为他是奸邪，因为他怂恿宋真宗大兴土木，后来被王曾和刘皇后扳倒。丁谓的价值观念与周围其他人不同，所以让其他人害怕他，甚至排斥他。（德国哲学家尼采，拥有超人的生命力）</li></ul><h3 id="1022"><a href="#1022" class="headerlink" title="1022"></a>1022</h3><ul><li>宋真宗病重驾崩。宋真宗这一生至少认清了这一阶段国家的首要挑战。开国皇帝会留下衍生问题给第二代君主，第三代君主来完善治理体系。宋真宗阶段首要挑战是以后再也不会有太祖太宗那样武将出身的皇帝，以后的皇帝都是深宫里出来的。所以皇帝的能力会越来越差，宋真宗通过善用宰相弥补这一点。真宗强调祖宗之法不可变，还打造新型权威，写一堆文章、搞神道设教。宋真宗一辈子都在弥补自身的弱点不足，且一旦自己想做就有一种执念一定要干。比如真宗不惜多次造假，一定要册封出身寒微的刘氏为皇后。宋真宗有体察别人的能力，设身处地的同情心，能全面考察问题的复杂性，会根据儒家价值观念约束自己。（唐太宗，也曾遍体鳞伤）</li></ul><h3 id="1023"><a href="#1023" class="headerlink" title="1023"></a>1023</h3><ul><li>宋仁宗继位，刘太后垂帘听政掌权，刘太后有领导力，在交替时刻，能认识到自己的新身份和新责任。且太后不结党，不拉帮结派。儒家讲究男权和孝道，二者并存，有时会有冲突。大臣们怕女主专权、外戚专权，太后既重要又不受待见。但是刘太后掌权期间人们非常满意。外戚专权之后一定会对皇权有极大威胁。宋朝没有发生过外戚之乱，因为宋朝就是外戚篡权建立的，所以防范得紧。宋朝规定，外戚能当官但不能掌权（枢密使，宰相，侍从官），例如钱惟演因为是外戚，所以一辈子当不成宰相。大臣们一直旁敲侧击地阻止刘太后女主专权。宋朝政治制度上创新不多，但是擅长补制度漏洞。事为之防，曲为之制，虽然能防患于未然，但是削弱了兵力，甚至造成了岳飞的悲惨下场。（杨联陞，生活丰富）</li></ul><h3 id="1024"><a href="#1024" class="headerlink" title="1024"></a>1024</h3><ul><li>《宋真宗实录》编完（后来失传了）。宋朝发明纸币——四川的交子。欧洲因为长期分裂，所以纸币是从搞货币兑换的银行演化而来的。中国大一统，且重农抑商，没有产生银行，宋朝当时出现钱荒，铜钱不足，铜钱流失严重，挖铜矿铸钱抵不上铜钱消耗，所以纸币应运而生。唐宋时期人们普遍喜欢喝茶，铜钱更不够用了。一开始纸币是私交子，一些四川地方商人提供类似银行的职责，后周转投资失败，后来由四川地方官主持发行官交子。为什么在四川？因为相比于当时其他地方，四川商业更发达，且货币问题更严重（四川用又重又贬值又容易腐朽的铁钱）。交子的出现，体现了当时人对庞大社会体系的信任，这是一代代积累的结果。创新是不断摸索，不断积累基本条件，然后交给运气。船是造船师塑造的，也是大海塑造的。（彭信威，货币史学家，《中国货币史》）</li></ul><h3 id="1025"><a href="#1025" class="headerlink" title="1025"></a>1025</h3><ul><li>宰相王钦若去世。王钦若是大文学家，主持编纂了《册府元龟》，但也是“五鬼”之一。史书上记载，王钦若很窝囊，导致很多人和同僚，甚至老婆都经常嘲笑他。刘太后很看重家世。魏晋南北朝时期，世家大族势力强大，他们的权力是软实力，这是声望现象。当时士族垄断了知识学问（三千万单词现象，知识学问在家庭代际间会放大），也就垄断了朝廷官员的网络，垄断了社会声望（获得社会声望的途径是跟有声望的东西在一起，所以南北朝时期讲究门当户对）（比如《西厢记》的崔莺莺）。士族不愿意惹上皇家姻亲，也犯不上姻亲。（阀阅：士族门口立的两根柱子）当时世家大族驯化了皇权，皇帝除了世家大族没人任用。印刷术和科举制打破了世家大族对知识的垄断，造成了士族社会的终结，进入了平民社会。北宋官员通过与进士的联姻维持家族延续，这需要投资眼光，所以很难保持延续。所以一个家族需要集中资源培养自家年轻人中进士，一代代群策群力供读书人科举，一部分人负责读书，一部分人负责赚钱养家，一部分人负责干活，这就是宗族社会。从此，光宗耀祖成了中国人的共识。《百家姓》中姓氏没有排名（除了前四个），这也意味着进入了宗族社会。</li></ul><h3 id="1026"><a href="#1026" class="headerlink" title="1026"></a>1026</h3><ul><li>茶法改革引发了一场舞弊案。茶叶在宋朝是普遍流行的饮品。茶里面有咖啡碱成分，有一定成瘾性，消耗量巨大，且需要复杂的交易网络，以及可以远程物流，所以市场规模大。朝廷通过茶法改革征税利用茶贸易赚钱。古代的税柄有三个：人口，土地，商业。朝廷卖茶引来管理商人，茶引类似营业执照，能调动商人积极性，也能让朝廷赚钱。茶叶在宋朝十分流行，是一种消费主义，众多文人也促成了茶文化，还是国际贸易商品，也成为了战略物资（茶马贸易、以茶治边）。人类文明经常会对外部资源有积极的开放性，且会不断产生共生关系。新事物会改变人类文明，也成为了人类文明的一部分。人类是万物的尺度，一个物种的价值取决于对人类的价值。对所有看似无用的外部资源保持开放性，可能有一天它有大用处。</li></ul><h3 id="1027"><a href="#1027" class="headerlink" title="1027"></a>1027</h3><ul><li>九年前的黄河决口终于堵上（用埽）。宋辽关系表面和平，实则一直存在矛盾，宋朝因为辽是游牧文明所以看不起辽朝。游牧民族可能源自农耕民族。游牧需要技术：马，金属冶炼技术（青铜器：生产工具）。游牧民族更喜欢生活在欧亚草原带。游牧民族对文字需求没有农耕民族高，但是所需技术却不简单。游牧的目的有两种：一是趋利，寻找资源丰富的地方；二是避害，躲避灾害（白灾：雪灾，黑灾：冬天不降雪，黄灾：沙尘暴，鼠灾，狼灾等等），所以游牧文明需要更强的信息探查能力。农耕文明的管理需要秩序规则，而游牧文明相对自由不需要规矩约束。游牧文明的秩序基于最纯朴的对上天的信仰，有独特的生存逻辑。正是游牧民族给中华民族注入新鲜血液，重塑中华文明。（田余庆，历史学家，“实处见虚真货色，无中生有臭文章”，基于史实作出合理推测）</li></ul><h3 id="1028"><a href="#1028" class="headerlink" title="1028"></a>1028</h3><ul><li>宰相张知白在岗位上去世。隐士林逋去世，受到皇帝追授谥号“和靖先生”。（梅妻鹤子）林逋是奇怪的隐士，隐居在繁华热闹的杭州西湖孤山岛，而且当时皇帝经常拜访送东西给他。从先秦时代到宋朝，隐士从对抗朝廷征召甚至付出代价，到受朝廷尊敬，因为能凸显隐士的高尚和皇帝的爱才。但是在科举制下，隐士铸剑失去了独立的政治姿态和角色，隐士文化逐渐衰落。除了和皇权的矛盾，隐士文化还有和儒家思想的矛盾。隐士看似躺平，其实都在积极实现自己的目标（比如白居易隐居时一直在忙着将自己的作品保存留存）。科举制给所有人定了一个大方向目标，就是读书考试当官，而隐士则选择了另一条少有人理解道路并为之奋斗。（隐士 陶渊明）</li></ul><h3 id="1029"><a href="#1029" class="headerlink" title="1029"></a>1029</h3><ul><li>玉清昭应宫烧毁，王曾被刘太后罢相，枢密使曹利用被撤换后被逼死。曹利用可能被太后设局。曹利用的官属于“武选官”（宋朝特有），介于文官与武官之间，这种官凭借皇帝的私人信任，为皇帝办事，后来成为了官员子弟的出路，所以越来越多人。武选官掌握军权，且与皇帝的关系亲而不尊。曹利用性格莽撞，但听皇帝的话，不顾一切地表忠心。所以莽撞得罪人，是他表明忠诚的方法。只依靠忠诚于某人或者某公司而生存的人是单维生存者，靠自己的人际网络，独立能力等的是多维生存者。单维生存者一旦失去信任便会跌落谷底，而多维生存者有能力东山再起。（李白 《妾薄命》）</li></ul><h3 id="1030"><a href="#1030" class="headerlink" title="1030"></a>1030</h3><ul><li>宋朝缺马，只能挖战壕驻城寨防御外敌。养马为了利用它的速度，一开始是经济工具、生产工具，拉车或者放牧。后来主要用于战场。中原的骑兵不一定不如草原骑兵，比如汉朝的卫青霍去病和唐太宗灭东突厥，但是宋朝因为没有好马场，所以骑兵不行。农耕文明养马会挤占耕地，而游牧文明养马跟放牧生活不冲突。其次，宋朝是募兵制，国家养马不划算；游牧民族是自己养马，积极性高。而且，宋朝战马优先分配给皇家的禁军，给到骑兵的马少。因为骑兵不行，所以宋朝重点研发远程武器，一开始是强弓硬弩，后来是火器，热武器，为了应对骑兵。创新很多是来源于其他路走不通，所以选择了另一条不同的路。文明和工具互相塑造。工具带来文明发展途径、思维方式的改变，文明也带来工具的演化。</li><li>为什么汉唐的骑兵能赢匈奴突厥？因为汉唐骑兵用的方法是冲击式骑兵，近身肉搏，而游牧民族是速度式骑兵，骑射为主，所以汉唐骑兵对游牧骑兵冲击力强，后来历朝历代不断发展冲击式骑兵。（苏轼《江城子 密州出猎》）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《文明之旅》 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信3：Cytoscape + STRING</title>
      <link href="/2025/02/11/sheng-xin-3-cytoscape-string/"/>
      <url>/2025/02/11/sheng-xin-3-cytoscape-string/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、Cytoscape"><a href="#1、Cytoscape" class="headerlink" title="1、Cytoscape"></a>1、Cytoscape</h2><ul><li>Cytoscape 是一个专注于开源网络可视化和分析的软件。它的核心是提供基础的功能布局和查询网络，并依据基本的数据的结合成可视化网络。</li><li>Cytoscape 源自系统生物学，用于将生物分子交互网络与高通量基因表达数据和其他的分子状态信息整合在一起，其最强大的功能还是用于大规模蛋白质-蛋白质相互作用、蛋白质-DNA和遗传交互作用的分析。</li></ul><h2 id="2、STRING"><a href="#2、STRING" class="headerlink" title="2、STRING"></a>2、STRING</h2><ul><li>STRING数据库是一个预测蛋白质间相互作用的综合数据库。它不仅包含了实验验证的直接物理性蛋白质-蛋白质相互作用，还包括了通过基因邻接、基因融合事件、基因共表达、文本挖掘等方法推断出的功能关联。</li><li>蛋白质互作网络（PPI网络），在STRING数据库中，是通过将不同的蛋白质作为节点，它们之间的相互作用作为边来构建的一种网络模型。这种网络可以帮助研究人员理解细胞内的复杂过程，如信号传导路径、代谢途径和疾病机制等。</li></ul><h1 id="二、使用STRING数据库生成一张PPI网络图"><a href="#二、使用STRING数据库生成一张PPI网络图" class="headerlink" title="二、使用STRING数据库生成一张PPI网络图"></a>二、使用STRING数据库生成一张PPI网络图</h1><ul><li><p>打开STRING在线网站：<a href="https://cn.string-db.org/">https://cn.string-db.org/</a><br><img src="https://s2.loli.net/2025/02/11/d71vBzcoG38pnYQ.png" alt="image.png"></p></li><li><p>按照蛋白质名称，氨基酸序列等信息进行检索某个特定的蛋白质相互作用的其他蛋白质<br><img src="https://s2.loli.net/2025/02/11/bDl5gzt2NWOwcpH.png" alt="image.png"><br><em>这里选BRCA1（乳腺癌易感蛋白1）</em></p></li></ul><p><img src="https://s2.loli.net/2025/02/11/68wUdTyjIAZlC21.png" alt="image.png"><br><em>选第一个，人类，点击continue</em></p><ul><li>展示与人类BRCA1互作的蛋白网络<br><img src="https://s2.loli.net/2025/02/11/XT6ZzyYKRoAb8rf.png" alt="image.png"><br><em>圆圈代表蛋白质，点击圆圈可以查看蛋白质相关信息；拖动圆圈可以移动位置；<br>直线代表蛋白质之间相互作用，点击可以查看互作信息</em></li></ul><p><img src="https://s2.loli.net/2025/02/11/O2SMpz5WiCgu46w.png" alt="image.png"><br><em>Known Interactions：即来自数据库或者实验中的数据；<br>Predicted Interactions：即基因邻接，基因融合，基因共现；<br>Others：即文本挖掘，共表达，蛋白同源性</em></p><ul><li><p>用Settings调整网络图：<br><img src="https://s2.loli.net/2025/02/11/UlNbzdjZBk8yLYW.png" alt="image.png"><br><em>Network type: 网络类型，默认只选择“full STRING network”；<br>meaning of network edges：网络线型，两个选项分别表示两个蛋白质之间交互的类型或者两个相连蛋白质之间连接的数据强度；<br>evidence：不同颜色的线表示不同证据；<br>confidence：两个蛋白质相互作用越强连线越粗；<br>active interaction sources：网络图交互数据来源；<br>minimum required interaction score:最低要求的交互置信度，数值越大，节点越少</em></p></li><li><p>调整网络图：<br><img src="https://s2.loli.net/2025/02/11/1f9RFHNPA2u63Mr.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/11/ah4pIFmMK6YdkZB.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/11/9whRVyuGoPX3Bt8.png" alt="image.png"></p></li><li><p>用Analysis进行简单的分析：<br><img src="https://s2.loli.net/2025/02/11/ZVErAIiNv5WPTw9.png" alt="image.png"><br><em>进行一些简单的网络分析，得到蛋白参与的功能描述；<br>这些分析结果，在本页下方提供了下载，方便其他应用直接使用</em></p></li><li><p>用Clusters进行聚类：<br><img src="https://s2.loli.net/2025/02/11/Tqogr6jt4VZ9mAc.png" alt="image.png"><br><em>一般是默认为不聚类的，如果需要对图中的节点进行聚类分析，可以点击kmeans clustering进行聚类；<br>每一种颜色代表一个聚类；<br>下方出现聚类的标志和个数，以及对应的蛋白名称等</em></p></li></ul><p><img src="https://s2.loli.net/2025/02/11/RYr62k8zFOjCbq7.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/11/yD25GlHzB9xp3oA.png" alt="image.png"></p><h1 id="三、Cytoscape与STRING联用"><a href="#三、Cytoscape与STRING联用" class="headerlink" title="三、Cytoscape与STRING联用"></a>三、Cytoscape与STRING联用</h1><ul><li><p>Cytoscape界面（自行安装）：<br><img src="https://s2.loli.net/2025/02/11/AKur8iCxnsOyMJW.png" alt="image.png"></p></li><li><p>在Cytoscape中安装STRING软件库：<br><img src="https://s2.loli.net/2025/02/11/kTv5ScQxKbJVtWC.png" alt="image.png"></p></li><li><p>利用STRING导入蛋白互作网络：</p><ul><li>File-&gt;import -&gt; network -&gt; public databases  </li><li>选择string数据库，以基因或蛋白输入<br><img src="https://s2.loli.net/2025/02/11/BAzGRHZo7e328Sy.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/11/FQkWbU1AwSHKxyo.png" alt="image.png"><br><em>输入BRCA1，score=0.20，连接的基因最大为80个</em></li></ul></li><li><p>展示蛋白互作网络：<br><img src="https://s2.loli.net/2025/02/11/eUPfucg65JACF2z.png" alt="image.png"><br>改为score=0.40，连接的基因最大为20个：<br><img src="https://s2.loli.net/2025/02/11/vgGz6q198XIpjd2.png" alt="image.png"></p></li><li><p>美化STRING网站上保存的网络图：</p><ul><li>保存网络图：<br><img src="https://s2.loli.net/2025/02/11/8cplxGSoPqbnLWO.png" alt="image.png"></li></ul></li><li><p>载入网络图到Cytoscape：<br><img src="https://s2.loli.net/2025/02/11/vFHSTquVb4Ut9Q7.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/11/LkKcxMdV2DPHgmX.png" alt="image.png"><br>进行进一步美化<br>展示效果图：<br><img src="https://s2.loli.net/2025/02/11/pEiHbTWadfR7Zhu.png" alt="image.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相互作用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习6——回归与聚类</title>
      <link href="/2025/02/08/ji-qi-xue-xi-6-hui-gui-yu-ju-lei/"/>
      <url>/2025/02/08/ji-qi-xue-xi-6-hui-gui-yu-ju-lei/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</strong></p><hr><ul><li>深度学习 ⊆ <strong>机器学习</strong> ⊆ 人工智能<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是由机器学习发展而来</li></ul></li><li>应用领域：传统预测、图像识别、自然语言处理</li><li>理论书：《机器学习》“西瓜书”、《统计学习方法》</li><li>库：<strong>sklearn</strong></li><li>==<strong>模型选择</strong>==：<br><img src="https://s2.loli.net/2025/02/01/kAj2tX7rLOn5FMq.png" alt="image.png"><br><em>现在应用广泛的是<strong>集成学习算法</strong>（多个弱学习器组成强学习器）：</em></li><li><em>Bagging（投票制，并行）：随机森林</em></li><li><em>Boosting（残差拟合，串行）：GBDT、XGBoosting、LightGBM、CatBoosting</em></li></ul><h1 id="六、回归与聚类算法"><a href="#六、回归与聚类算法" class="headerlink" title="六、回归与聚类算法"></a>六、回归与聚类算法</h1><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==regression_clustering.py==文件</strong></em></p><ul><li>回归问题：标签值为连续型数据</li><li>其他回归算法：Lasso、决策树、部分集成学习算法（随机森林、梯度提升、<strong>XGBoost</strong>）</li></ul><h2 id="1、线性回归"><a href="#1、线性回归" class="headerlink" title="1、线性回归"></a>1、线性回归</h2><ul><li>用回归方程进行对一个或多个特征（自变量）与标签值（因变量）之间的关系进行建模<ul><li>一个特征：单变量回归</li><li>多个特征：多元回归（一般）</li></ul></li></ul><h3 id="（1）线性模型"><a href="#（1）线性模型" class="headerlink" title="（1）线性模型"></a>（1）线性模型</h3><p><img src="https://s2.loli.net/2025/02/01/P8s14qNoEFnmTZh.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/01/hPGnJ6kRtYNjTOZ.png" alt="image.png"><br><em>↑两个特征的多元回归示意图</em></p><ul><li>广义线性模型：<ul><li>线性关系：直线、平面等（自变量一次）</li><li>非线性关系：曲线等（参数一次）</li></ul></li></ul><h3 id="（2）损失函数"><a href="#（2）损失函数" class="headerlink" title="（2）损失函数"></a>（2）损失函数</h3><ul><li>目标：求模型参数使得预测准确</li><li><strong>衡量真实值和预测值之间的误差</strong></li><li>平方损失函数：<br><img src="https://s2.loli.net/2025/02/01/9kzDtreXQ6EoJi4.png" alt="image.png"></li><li>其他损失函数见：<a href="https://blog.csdn.net/Next_SummerAgain/article/details/129550772">【机器学习】损失函数(Loss Function)全总结(2023最新整理)关键词：Logistic、Hinge、Exponential、Modified Huber、Softmax、L1、L2正则化_huber损失函数-CSDN博客</a></li></ul><h3 id="（3）优化方法"><a href="#（3）优化方法" class="headerlink" title="（3）优化方法"></a>（3）优化方法</h3><ul><li>正规方程、<strong>随机梯度下降（SGD，重要！！！）</strong></li></ul><h4 id="①正规方程"><a href="#①正规方程" class="headerlink" title="①正规方程"></a>①正规方程</h4><ul><li><p>直接求解W权重：<br><img src="https://s2.loli.net/2025/02/01/kboeLSqUdwpYihx.png" alt="image.png"></p></li><li><p>理解：损失函数L对每一个特征偏导=0，求得最小值时，W的取值</p></li><li><p><strong>缺点</strong>：当特征过多过复杂时，求解速度太慢且得不到结果，时间复杂度高O(n3)</p></li></ul><p><strong>API：</strong></p><ul><li>sklearn.linear_model.LinearRegression(参数)<ul><li>参数：<ul><li>fit_intercept=：是否添加偏置，一般True</li></ul></li><li>使用：<ul><li>LinearRegression.coef_：查看回归系数</li><li>LinearRegression.intercept_：查看偏置</li></ul></li></ul></li></ul><h4 id="②-随机梯度下降"><a href="#②-随机梯度下降" class="headerlink" title="②==随机梯度下降=="></a>②==随机梯度下降==</h4><ul><li><p>stochastic gradient descent（<strong>SGD</strong>）</p></li><li><p>逐步迭代改进W：（第二个式子后一项应该为对w0求偏导，不是w1）<br><img src="https://s2.loli.net/2025/02/01/47tr8UTuWqosdlZ.png" alt="image.png"></p></li><li><p><strong>缺点</strong></p><ul><li>损失函数L只降到局部最小值，而不是全局最小值</li><li>很多超参数，需要调参</li><li>对特征标准化敏感</li></ul></li></ul><p><strong>API：</strong></p><ul><li>sklearn.linear_model.SGDRegressor(参数)<ul><li><p>参数：</p><ul><li>fit_intercept=：是否添加偏置，一般True</li><li>loss=：损失函数类型，默认’squared_loss’（平方损失函数）</li><li><strong>learning_rate</strong>=：学习率（eta）填充<ul><li>‘invscaling’：<strong>默认</strong>，学习率eta=eta0 / pow(t , pow_t)<ul><li>pow_t：默认=0.25</li></ul></li><li>‘constant’：学习率为常数，eta=eta0</li><li>‘optimal’：eta=1.0 / (alpha×(t + t0))</li></ul></li><li>alpha=：用来作为’optimal’中的alpha，默认=0.0001</li><li>eta0=：用来作为’constant’中的eta0，默认=0.01</li><li>power_t=：用来作为’invscaling’中的pow_t，默认=0.25</li><li>max_iter=：迭代次数</li><li>……</li></ul></li><li><p>使用：</p><ul><li>SGDRegressor.coef_：查看回归系数</li><li>SGDRegressor.intercept_：查看偏置</li></ul></li></ul></li></ul><h4 id="③其他优化方法"><a href="#③其他优化方法" class="headerlink" title="③其他优化方法"></a>③其他优化方法</h4><ul><li>梯度下降（GD）：最原始的梯度下降，计算量大</li><li>随机平均梯度下降（SAG）：SGD的改进</li><li>理解更多优化算法见：<a href="https://zhuanlan.zhihu.com/p/51184012">如何理解SAG,SVRG,SAGA三种优化算法 - 知乎</a></li></ul><h3 id="（4）回归模型评估"><a href="#（4）回归模型评估" class="headerlink" title="（4）回归模型评估"></a>（4）回归模型评估</h3><ul><li>均方误差评估：<br><img src="https://s2.loli.net/2025/02/01/a5IxglUjvkBdSR3.png" alt="image.png"></li></ul><p><strong>API：</strong></p><ul><li><p>sklearn.metrics.mean_squared_error(y_true , y_pred)</p><ul><li>参数：<ul><li>y_true：真实值</li><li>y_pred：预测值</li></ul></li><li>return：偏差值</li></ul></li><li><p>其他评估方法见：<a href="https://blog.csdn.net/fengdu78/article/details/127761729">【机器学习】12种回归评价指标-CSDN博客</a></p></li></ul><h3 id="案例：用SGD预测加州房价"><a href="#案例：用SGD预测加州房价" class="headerlink" title="- 案例：用SGD预测加州房价"></a>- 案例：用SGD预测加州房价</h3><pre class="line-numbers language-python"><code class="language-python">house <span class="token operator">=</span> fetch_california_housing<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 获取数据集（注意需要魔法）</span><span class="token comment" spellcheck="true"># print("特征数量", house.data.shape)</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>house<span class="token punctuation">.</span>data<span class="token punctuation">,</span> house<span class="token punctuation">.</span>target<span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 划分数据集</span><span class="token comment" spellcheck="true"># 需要比较正规方程和随机梯度下降哪个好，所以随机数种子设置相同</span><span class="token comment" spellcheck="true"># 标准化</span>trans <span class="token operator">=</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span>x_train <span class="token operator">=</span> trans<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x_train<span class="token punctuation">)</span>x_test <span class="token operator">=</span> trans<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 预估器流程</span>esti <span class="token operator">=</span> SGDRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 可以调参优化，调学习率等</span>esti<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 得出模型</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"linear_SGDR权重系数：\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>coef_<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"linear_SGDR偏置：\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>intercept_<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 评估模型</span>y_pred <span class="token operator">=</span> esti<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"linear_SGDR预测房价：\n"</span><span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>error <span class="token operator">=</span> mean_squared_error<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"linear_SGDR均方误差：\n"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>输出</em>：<br><img src="https://s2.loli.net/2025/02/01/E7scNMB6HPywaUV.png" alt="image.png"></p><h2 id="2、欠拟合、过拟合"><a href="#2、欠拟合、过拟合" class="headerlink" title="2、欠拟合、过拟合"></a>2、欠拟合、过拟合</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul><li>欠拟合：训练集上不能很好拟合，测试集上也不行（模型过于简单）</li><li><strong>过拟合</strong>：训练集上能很好地拟合，但测试集上不行（模型过于复杂）<br><img src="https://s2.loli.net/2025/02/02/nG2aKB43oLzN8TQ.png" alt="image.png"><br><em>最好<strong>将模型复杂度保持在测试误差最小</strong>的时候，也就是↑图中的测试误差最低点</em></li></ul><h3 id="（2）原因及解决方法"><a href="#（2）原因及解决方法" class="headerlink" title="（2）原因及解决方法"></a>（2）原因及解决方法</h3><ul><li><p>欠拟合：</p><ul><li>原因：学习到的特征过少</li><li>解决：增加数据或增加特征</li></ul></li><li><p>过拟合：</p><ul><li>原因：学习到的特征过多，有一些嘈杂特征</li><li>解决：<strong>正则化</strong>（针对回归）</li></ul></li><li><p>实际应用中数据量大，主要解决过拟合</p></li></ul><h3 id="（3）正则化"><a href="#（3）正则化" class="headerlink" title="（3）正则化"></a>（3）正则化</h3><ul><li><p>解决过拟合问题</p></li><li><p>L1正则化：</p><ul><li>作用：使某些W直接变为0，删除对应特征的影响</li><li>加入L2正则化项之后的新损失函数（LASSO回归）：<br>  <img src="https://s2.loli.net/2025/02/02/S46PqUQkvz2WRXe.png" alt="image.png"><br>  <em>↑第一项为原线性回归损失函数，第二项为L1正则化项</em><br>  <em>其中L1正则化项为惩罚项，α为正则化系数（惩罚系数）</em></li></ul></li><li><p><strong>L2正则化</strong>：</p><ul><li>作用：可以使某些W很小，削弱对应特征的影响</li><li>加入L2正则化项之后的<strong>新损失函数</strong>（Ridge回归，岭回归）：<br>  <img src="https://s2.loli.net/2025/02/02/tkZUoy8IhSaFgO7.png" alt="image.png"><br>  <em>↑第一项为原线性回归损失函数（一般会 ÷2n），第二项为L2正则化项</em><br>  <em>其中L2正则化项为惩罚项，α为正则化系数（惩罚系数）</em></li></ul></li><li><p><strong>一般L2正则化最常用</strong></p></li></ul><h2 id="3、岭回归"><a href="#3、岭回归" class="headerlink" title="3、岭回归"></a>3、岭回归</h2><ul><li>普通线性回归的改进：<strong>带L2正则化</strong>的线性回归（Ridge回归）</li><li>能解决过拟合问题</li></ul><p><strong>API：</strong></p><ul><li>sklearn.linear_model.Ridge(参数)<ul><li><p>参数：</p><ul><li>alpha=：正则化系数α（正则化力度），默认1.0</li><li>fit_intercept=：是否添加偏置，一般True</li><li>solver=：’auto’ 自动选择优化方法（如果数据比较多，自动选择SAG优化器）</li><li>normalize=：数据是否进行标准化，默认False，True就不用进行特征工程的标准化</li><li>max_iter=：迭代次数</li></ul></li><li><p>使用：</p><ul><li>Ridge.coef_：查看回归系数</li><li>Ridge.intercept_：查看偏置</li></ul></li></ul></li></ul><p><em>Ridge( )相当于SGDRegressor(penalty=’l2’ , loss=’squared_loss’)，只是SGD是随机梯度下降优化方法，Ridge是SAG优化方法，推荐用Ridge</em></p><h2 id="4、逻辑回归、二分类问题"><a href="#4、逻辑回归、二分类问题" class="headerlink" title="4、逻辑回归、二分类问题"></a>4、逻辑回归、二分类问题</h2><ul><li>属于<strong>分类算法</strong></li></ul><h3 id="（1）逻辑回归"><a href="#（1）逻辑回归" class="headerlink" title="（1）逻辑回归"></a>（1）逻辑回归</h3><ul><li><p>Logistic Regression，与回归有关的一种分类算法，应用广泛</p></li><li><p>能很好地解决<strong>二分类问题</strong></p></li><li><p>线性回归的输出 -&gt; 逻辑回归的输入，将线性回归的输出（Wx+b）作为激活函数的x输入</p></li><li><p><strong>Sigmoid激活函数</strong>：<br><img src="https://s2.loli.net/2025/02/02/9QL3qF1Eu5C7WZv.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/02/z7E5mYUD8xHCBAv.png" alt="image.png"><br><em>将 Wx+b 映射到 0-1 区间</em></p></li><li><p><strong>分类标准</strong>：</p><ul><li>经过Sigmoid函数映射后&gt;设定的阈值（默认0.5）的认为属于这一类别，&lt;阈值的认为不属于</li></ul></li><li><p>损失函数：</p><ul><li><p><strong>对数似然损失函数</strong>：<br>  <img src="https://s2.loli.net/2025/02/02/BaUScmCgZTpH4IP.png" alt="image.png"><br>  <em>if y=1表示<strong>真实值</strong>属于这一类别，hθ(x)表示Sigmoid函数的输出值，log以e为底</em></p></li><li><p>也就是（一般会 ÷n）：<br>  <img src="https://s2.loli.net/2025/02/02/DTRbysKIk3oFQdM.png" alt="image.png"><br>  <em>这个损失函数能够满足逻辑回归的损失函数性质</em></p></li></ul></li><li><p>还是用<strong>梯度下降</strong>法来优化损失函数</p></li></ul><p><strong>API：</strong></p><ul><li>sklearn.linear_model.LogisticRegression(参数)<ul><li>参数：<ul><li>solver=：优化求解方法<ul><li>‘liblinear’：默认，自动选择</li><li>‘sag’：SAG优化方法</li></ul></li><li>penalty=：正则化种类，默认’l2’</li><li>C=：正则化参数，默认=1.0</li></ul></li></ul></li></ul><p><em>SGDClassifier(loss=’log’ , average=True)类似，但是实现的是ASGD优化方法</em></p><h3 id="（2）二分类模型评估方法"><a href="#（2）二分类模型评估方法" class="headerlink" title="（2）二分类模型评估方法"></a>（2）二分类模型评估方法</h3><ul><li>理想中：用之前分类算法中的准确率（查准率）评估</li><li><strong>实际</strong>：还需要结合查全率（召回率）、AUC等<strong>指标</strong></li><li><strong>样本均衡</strong>：精确率、召回率、F1-score</li><li><strong>样本不均衡</strong>：ROC曲线、AUC指标</li></ul><h4 id="①精确率、召回率"><a href="#①精确率、召回率" class="headerlink" title="①精确率、召回率"></a>①精确率、召回率</h4><ul><li><p>混淆矩阵：<br><img src="https://s2.loli.net/2025/02/02/EiAvoORlDcIBxT5.png" alt="image.png"><br><em>其中TP+FN+FP+TN=样例总数，TP即True Positive，FN即False Negative</em></p></li><li><p><strong>精确率P</strong>（查准率）：预测结果为正例中实际正例的占比<br><img src="https://s2.loli.net/2025/02/02/LWpwhXDfOY12Kx5.png" alt="image.png"><br><em>精确率 P=TP / (TP + FP)</em></p></li><li><p><strong>召回率R</strong>（查全率）：真实情况为正例中预测正例的占比（查的全不全）<br><img src="https://s2.loli.net/2025/02/02/QxmSje3hW5bNVyi.png" alt="image.png"><br><em>召回率 R=TP / (TP + FN)</em></p></li></ul><h4 id="②F1度量指标"><a href="#②F1度量指标" class="headerlink" title="②F1度量指标"></a>②F1度量指标</h4><ul><li>F1-score，反映模型的<strong>稳健性</strong>：<br><img src="https://s2.loli.net/2025/02/02/N8HBtl3ZfudUxgF.png" alt="image.png"><br><em>综合了精确率与召回率</em></li></ul><h4 id="API"><a href="#API" class="headerlink" title="- API"></a>- API</h4><ul><li>sklearn.metrics.classification_report(y_true , y_pred , labels=[ ] , target_names= )<ul><li>参数：<ul><li>y_true：真实标签值</li><li>y_pred：预测标签值</li><li>labels=：分类的类别对应的数字</li><li>target_names=：数字对应的类别名称（字符串）</li></ul></li><li>比如：<ul><li>report = classification_report(y_test, y_pred, labels=[2, 4], target_names=[‘良性肿瘤’, ‘恶性肿瘤’])</li></ul></li><li>return：精确率、召回率、F1-score等指标<br><em>输出样例：</em><br><img src="https://s2.loli.net/2025/02/02/xQDvegpKuW4oUqf.png" alt="image.png"><br><strong>重点关注召回率（recall）</strong></li></ul></li></ul><h4 id="③ROC曲线、AUC指标"><a href="#③ROC曲线、AUC指标" class="headerlink" title="③ROC曲线、AUC指标"></a>③ROC曲线、AUC指标</h4><ul><li><p><strong>样本不均衡</strong>情况下，精确率、召回率、F1-score不能很好评估模型</p></li><li><p>真阳性率（TPR）：真实情况为正例中预测正例的占比，TP / (TP + FN)，=召回率</p></li><li><p>假阳性率（FPR）：真实情况为反例中预测正例的占比，FP / (TN + FP)<br><img src="https://s2.loli.net/2025/02/02/EiAvoORlDcIBxT5.png" alt="image.png"></p></li><li><p><strong>ROC曲线</strong>：</p><ul><li>横坐标FPR，纵坐标TPR</li><li>曲线越靠近左上角（TPR-&gt;1，FPR-&gt;0），模型越好<br><img src="https://s2.loli.net/2025/02/02/WsuOPf62aexRgtl.png" alt="image.png"><br><em>ROC曲线为蓝色的那条，AUC指标为ROC曲线下方到（1，0）点围成的面积</em><br><em>红色虚线为随机预测模型（瞎猜），此时AUC指标=0.5</em></li></ul></li><li><p><strong>AUC指标</strong>：</p><ul><li>概率意义：若随机抽取一个阳性样本和一个阴性样本，分类器<strong>正确判断</strong>阳性样本的值高于阴性样本的概率=AUC</li><li>最小值为0.5，最大值为1（越大越好），若&lt;0.5就反着看（反向预测）</li><li>几何意义：ROC曲线下方到（1，0）点围成的<strong>面积</strong></li><li>非常适合评估<strong>样本不均衡</strong>时的模型</li></ul></li></ul><h4 id="API-1"><a href="#API-1" class="headerlink" title="- API"></a>- API</h4><ul><li>sklearn.metrics.roc_auc_score(y_true , y_score)<ul><li>参数：<ul><li>y_true：每个样本的标签值，<strong>必须为0（反例）、1（正例）</strong></li><li>y_score：预测得分，也可以是正类的估计概率、置信值、分类器方法返回值 (y_pred)</li></ul></li><li>return：AUC指标（0~1）</li></ul></li></ul><h2 id="5、无监督学习——K-means算法"><a href="#5、无监督学习——K-means算法" class="headerlink" title="5、无监督学习——K-means算法"></a>5、无监督学习——K-means算法</h2><ul><li>无监督学习：<strong>无标签值</strong></li><li>包含算法：<ul><li><strong>聚类</strong><ul><li>K-means聚类</li></ul></li><li><strong>降维</strong><ul><li>PCA</li></ul></li></ul></li></ul><h3 id="（1）K-means"><a href="#（1）K-means" class="headerlink" title="（1）K-means"></a>（1）K-means</h3><ul><li><p><strong>优点</strong>：采用迭代式算法，直观、实用</p></li><li><p><strong>缺点</strong>：容易收敛到局部最优解</p><ul><li><strong>解决</strong>：多次聚类</li></ul></li><li><p><strong>应用场景</strong>：没有标签值的时候，一般先聚类，便于以后分类</p></li><li><p><strong>步骤</strong>：</p><ol><li>随机设置K个点作为初始聚类中心（K值为超参数，表示<strong>K个类</strong>，看需求，或者调参）</li><li>计算其他每个点到这K个点的距离，将自身标记为属于最近的一类</li><li>标记完所有点后，对K个类的每个类求中心点（求<strong>平均值means</strong>），作为新的聚类中心</li><li>如果新聚类中心与旧聚类中心相同（如果是第一次就与初始聚类中心比较），就结束，否则<strong>重复</strong>步骤2、3、4<br><img src="https://s2.loli.net/2025/02/03/xS3ctmEbl6BZGUr.png" alt="image.png"><br><strong>API：</strong></li></ol></li><li><p>sklearn.cluster.KMeans(参数)</p><ul><li>参数：<ul><li>n_clusters=：K值，分几类</li><li>init=：初始化方法，默认’k-means++’</li><li>labels_=：默认标识的类型，可以和真实值比较（不是值比较）</li></ul></li><li>训练：KMeans.fit(data)：data为<strong>特征值</strong>，没有标签值，不用传</li></ul></li></ul><h3 id="（2）聚类模型评估"><a href="#（2）聚类模型评估" class="headerlink" title="（2）聚类模型评估"></a>（2）聚类模型评估</h3><ul><li><p>轮廓系数：<br><img src="https://s2.loli.net/2025/02/03/sdneio1MSx7fm2l.png" alt="image.png"><br><em>轮廓系数是对某一个样本而言，bi为这个样本到其他类别样本的距离最小值，ai为这个样本到本类别其他所有样本的距离平均值</em><br>当bi&gt;&gt;ai，SCi=1；bi&lt;&lt;ai，SCi=-1；轮廓系数取值范围[-1 , 1]，<strong>SCi越接近 1 模型越好</strong></p></li><li><p>几何理解：<br><img src="https://s2.loli.net/2025/02/03/xM9v8zaS5U4Zhik.png" alt="image.png"><br><em>不同类之间离得远，类内样本间离得近</em></p></li></ul><p><strong>API：</strong></p><ul><li>sklearn.metrics.silhouette_score(X , labels=[ ])<ul><li>参数：<ul><li>X：特征值</li><li>labels：经过聚类标记的标签值，也就是用KMeans.predict(X)得到的<strong>y_pred</strong></li></ul></li><li>return：所有样本的平均轮廓系数</li></ul></li></ul><h3 id="案例：Instacart市场篮子分析（聚类部分）"><a href="#案例：Instacart市场篮子分析（聚类部分）" class="headerlink" title="- 案例：Instacart市场篮子分析（聚类部分）"></a>- 案例：Instacart市场篮子分析（聚类部分）</h3><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==instacart.ipynb==文件</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习5——分类算法</title>
      <link href="/2025/02/07/ji-qi-xue-xi-5-fen-lei-suan-fa/"/>
      <url>/2025/02/07/ji-qi-xue-xi-5-fen-lei-suan-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</strong></p><hr><ul><li>深度学习 ⊆ <strong>机器学习</strong> ⊆ 人工智能<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是由机器学习发展而来</li></ul></li><li>应用领域：传统预测、图像识别、自然语言处理</li><li>理论书：《机器学习》“西瓜书”、《统计学习方法》</li><li>库：<strong>sklearn</strong></li><li>==<strong>模型选择</strong>==：<br><img src="https://s2.loli.net/2025/02/01/kAj2tX7rLOn5FMq.png" alt="image.png"><br><em>现在应用广泛的是<strong>集成学习算法</strong>（多个弱学习器组成强学习器）：</em></li><li><em>Bagging（投票制，并行）：随机森林</em></li><li><em>Boosting（残差拟合，串行）：GBDT、XGBoosting、LightGBM、CatBoosting</em></li></ul><h1 id="五、分类算法"><a href="#五、分类算法" class="headerlink" title="五、分类算法"></a>五、分类算法</h1><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==classification.py==文件</strong></em></p><ul><li>标签值：<strong>类别</strong></li><li><strong>二分类问题</strong>见：逻辑回归与二分类（第六节）</li></ul><h2 id="1、kNN算法"><a href="#1、kNN算法" class="headerlink" title="1、kNN算法"></a>1、kNN算法</h2><ul><li><p>k-近邻算法，k-nearest neighbor classification</p></li><li><p>根据k个“邻居”推断自身类别</p></li><li><p>k个最相似（特征空间上最邻近）的样本大多属于一个类别，则推断所求样本类别也是这个类别</p></li><li><p><strong>k值</strong>：</p><ul><li>过小：容易受异常值影响</li><li>过大：容易受样本不均衡影响</li></ul></li><li><p><strong>计算距离</strong>：</p><ul><li>欧几里得（欧式）距离：平方差求和开根</li><li>曼哈顿距离：差绝对值求和</li><li>闵可夫斯基距离：对欧式距离和曼哈顿距离公式的概括性的表述</li></ul></li><li><p>==<strong>必须先做标准化再kNN，避免量级的支配影响！！！</strong>==</p></li><li><p><strong>优点</strong>：简单易实现</p></li><li><p><strong>缺点</strong>：</p><ul><li>k值选择不当影响精度</li><li>计算量大，内存消耗大</li></ul></li><li><p><strong>应用场景</strong>：小数据场景（几千~几万样本）</p></li></ul><p><strong>API：</strong></p><ul><li>sklearn.neighbors.KNeighborsClassifier(n_neighbors= )<ul><li>参数（可省略）：<ul><li>n_neighbors= ：<strong>k值</strong>，默认=5</li><li>algorithm= ：可选{‘auto’ , ‘ball_tree’ , ‘kd_tree’ , ‘brute’}，默认=’auto’，不同方法效率不同</li><li>默认用欧氏距离</li></ul></li><li>KNeighborsClassifier.fit(x_train , y_train)：训练</li><li>KNeighborsClassifier.predict(x_test)：预测</li><li>KNeighborsClassifier.score(x_test, y_test)：评估</li></ul></li></ul><h2 id="2、模型选择与调优"><a href="#2、模型选择与调优" class="headerlink" title="2、模型选择与调优"></a>2、模型选择与调优</h2><h3 id="（1）交叉验证"><a href="#（1）交叉验证" class="headerlink" title="（1）交叉验证"></a>（1）交叉验证</h3><ul><li><p>n折交叉验证（cross-validation，CV）：将训练集再分为训练集与验证集，分成n份（任意1份作为验证集，其他n-1份作为训练集），<strong>轮流进行验证</strong>，得到n个准确率，求平均作为总准确率<br><img src="https://s2.loli.net/2025/01/22/enrhWTqO3pJA6cL.png" alt="image.png"><br><em>↑四折交叉验证</em></p></li><li><p><strong>优点</strong>：让模型更加准确</p></li></ul><h3 id="（2）超参数搜索"><a href="#（2）超参数搜索" class="headerlink" title="（2）超参数搜索"></a>（2）超参数搜索</h3><ul><li>超参数：需要手动指定的参数（如k值）</li><li>网格搜索（Grid search）：预设几组超参数，每组采用交叉验证的方法评估，选出最优超参数</li><li>sklearn.model_selection.GridSearchCV(estimator , param_grid= , cv= )<ul><li><p>参数：</p><ul><li>estimator：算法实例</li><li>param_grid=：estimator的超参数选择（字典形式）<ul><li>如：{ ‘n_neighbors’ : [1 , 3 , 5] }</li></ul></li><li>cv=：指定几折交叉检验（常用10折）</li></ul></li><li><p>GridSearchCV.fit(x_train , y_train)：训练</p></li><li><p>GridSearchCV.predict(x_test)：预测</p></li><li><p>GridSearchCV.score(x_test, y_test)：评估</p></li><li><p>属性：</p><ul><li>最佳超参数：.best_params_</li><li>最佳结果：.best_score_</li><li>最佳预估器：.best_estimator_</li><li>交叉验证结果：.cv_results_</li></ul></li></ul></li></ul><h2 id="例：kNN预测鸢尾花类型"><a href="#例：kNN预测鸢尾花类型" class="headerlink" title="- 例：kNN预测鸢尾花类型"></a>- 例：kNN预测鸢尾花类型</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 1、读取数据</span>iris <span class="token operator">=</span> load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(iris)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 2、划分数据集</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(type(x_train))</span><span class="token comment" spellcheck="true"># 3、特征工程：标准化</span>trans <span class="token operator">=</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span>x_train <span class="token operator">=</span> trans<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x_train<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 对x_train进行标准化</span>x_test <span class="token operator">=</span> trans<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 对x_test也进行相同的标准化</span><span class="token comment" spellcheck="true"># 4、训练knn模型</span>esti <span class="token operator">=</span> KNeighborsClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 实例化一个预估器</span>para_grid <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'n_neighbors'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">}</span>esti <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>esti<span class="token punctuation">,</span> param_grid<span class="token operator">=</span>para_grid<span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 网格搜索+交叉验证</span>esti<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 训练</span><span class="token comment" spellcheck="true"># 5、评估模型</span>    <span class="token comment" spellcheck="true"># 方法1：</span>y_pred <span class="token operator">=</span> esti<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 预测</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"y_predict ="</span><span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"accuracy_1 ="</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>y_pred <span class="token operator">==</span> y_test<span class="token punctuation">)</span><span class="token operator">/</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>y_test<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算准确率</span>    <span class="token comment" spellcheck="true"># 方法2：</span>accuracy <span class="token operator">=</span> esti<span class="token punctuation">.</span>score<span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算准确率</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"accuracy_2 ="</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最佳参数：best_params_</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最佳参数：\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>best_params_<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最佳结果：best_score_</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最佳结果：\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>best_score_<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最佳估计器：best_estimator_</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"最佳估计器:\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>best_estimator_<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 交叉验证结果：cv_results_</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"交叉验证结果:\n"</span><span class="token punctuation">,</span> esti<span class="token punctuation">.</span>cv_results_<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>输出：</em><br><img src="https://s2.loli.net/2025/01/22/PsZR7CIAUbJK3m8.png" alt="image.png"></p><h2 id="案例：Facebook签到位置预测"><a href="#案例：Facebook签到位置预测" class="headerlink" title="- 案例：Facebook签到位置预测"></a>- 案例：Facebook签到位置预测</h2><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==facebook_knn.ipynb==文件</strong></em></p><h2 id="3、朴素贝叶斯算法"><a href="#3、朴素贝叶斯算法" class="headerlink" title="3、朴素贝叶斯算法"></a>3、朴素贝叶斯算法</h2><ul><li>分类结果是概率值，需要数据量大</li><li>原理：<strong>朴素+贝叶斯</strong><ul><li>贝叶斯：联合概率、条件概率、相互独立的概念定义，<strong>贝叶斯公式</strong></li><li><strong>朴素：假设特征之间相互独立</strong></li><li><strong>拉普拉斯平滑系数</strong>：<ul><li>防止计算出的分类概率为0</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2025/01/24/jsDlYi2fF6APIzr.png" alt="image.png"><br><em>α系数一般为1，m为训练文档中统计出的<strong>特征词数</strong>（所有有意义的特征词、不重复），N为所有C条件下所有词的个数，Ni为所有C条件下F1词的个数</em></p><ul><li>应用场景：<strong>文本分类</strong>（情感分析等）</li></ul><p><strong>API：</strong></p><ul><li>sklearn.naive_bayes.MultinormialNB(alpha=1.0)<ul><li><p>alpha=：拉普拉斯平滑系数（默认=1.0）</p></li><li><p>MultinormialNB.fit(x_train , y_train)：训练</p></li><li><p>MultinormialNB.predict(x_test)：预测</p></li><li><p>MultinormialNB.score(x_test, y_test)：评估</p></li></ul></li></ul><p>代码示例：</p><pre class="line-numbers language-python"><code class="language-python">news <span class="token operator">=</span> fetch_20newsgroups<span class="token punctuation">(</span>subset<span class="token operator">=</span><span class="token string">"all"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 获取数据集</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>news<span class="token punctuation">.</span>data<span class="token punctuation">,</span> news<span class="token punctuation">.</span>target<span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 划分数据集</span><span class="token comment" spellcheck="true"># 特征工程：文本特征抽取（Tf-idf）</span>trans <span class="token operator">=</span> TfidfVectorizer<span class="token punctuation">(</span><span class="token punctuation">)</span>x_train <span class="token operator">=</span> trans<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x_train<span class="token punctuation">)</span>x_test <span class="token operator">=</span> trans<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"type of x_test:"</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 朴素贝叶斯算法</span>esti <span class="token operator">=</span> MultinomialNB<span class="token punctuation">(</span><span class="token punctuation">)</span>esti<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 模型评估</span>    <span class="token comment" spellcheck="true"># 方法1：</span>y_pred <span class="token operator">=</span> esti<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 预测</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"y_predict ="</span><span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>accuracy_1 <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>y_pred <span class="token operator">==</span> y_test<span class="token punctuation">)</span><span class="token operator">/</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>y_test<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"accuracy_1 ="</span><span class="token punctuation">,</span> accuracy_1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算准确率</span>    <span class="token comment" spellcheck="true"># 方法2：</span>accuracy_2 <span class="token operator">=</span> esti<span class="token punctuation">.</span>score<span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算准确率</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"accuracy_2 ="</span><span class="token punctuation">,</span> accuracy_2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>输出：</em><br><img src="https://s2.loli.net/2025/01/24/fnJrHyuGwKaPoxI.png" alt="image.png"></p><ul><li><strong>优点</strong>：<ul><li>稳定的分类效率</li><li>对缺失值不太敏感，算法简单</li><li>速度快</li></ul></li><li><strong>缺点</strong>：<ul><li>由于假设特征之间相互独立，所以当特征关联性强的时候效果差</li></ul></li></ul><h2 id="4、决策树"><a href="#4、决策树" class="headerlink" title="4、决策树"></a>4、决策树</h2><ul><li><p>按照类似if…else…的结构分割数据，按顺序高效决策</p></li><li><p>需要决定按照特征的先后顺序</p></li><li><p>信息论基础：</p><ul><li>信息熵</li><li>信息增益：g(D , A) = 总信息熵 H(D) - 条件熵 H(D|A)<br><img src="https://s2.loli.net/2025/01/29/zji1luESoqfUayW.png" alt="image.png"></li></ul></li><li><p>根据<strong>不确定度减少最多</strong>的特征排序判断，也就是<strong>信息增益最大</strong>排序的特征判断</p></li></ul><p><strong>API：</strong></p><ul><li><p>sklearn.tree.DecisionTreeClassifier(criterion= , max_depth= , random_state= )</p><ul><li>决策树分类器</li><li>参数：<ul><li>criterion=：决策树划分依据，默认’gini’，可以选信息增益’entropy’</li><li>max_depth=：树的深度大小，默认None（拟合所有特征，可能会过拟合）</li><li>random_state=：随机数种子</li></ul></li></ul></li><li><p>决策树的<strong>可视化</strong>：</p><ul><li><p>sklearn.tree.export_graphviz(estimator , out_file=’xxx.dot’ , feature_names=[‘ ‘ , ‘ ‘])</p><ul><li>estimator：需要导出的训练好的预估器</li><li>out_file=：导出文件的名字，格式为.dot</li><li>feature_names=：导出的特征名字</li></ul></li><li><p>可以在网站<strong>webgraphviz</strong>中打开.dot文件查看树的形状，也可以在vscode中安装<strong>插件Graphviz Interactive Preview</strong>预览</p></li></ul></li><li><p><strong>优点</strong>：可视化，可解释能力强</p></li><li><p><strong>缺点</strong>：过于深的树容易过拟合</p></li><li><p><strong>改进</strong>：减枝cart算法，随机森林</p></li><li><p>应用范围：企业决策</p></li></ul><h2 id="案例：泰坦尼克号乘客生存预测"><a href="#案例：泰坦尼克号乘客生存预测" class="headerlink" title="- 案例：泰坦尼克号乘客生存预测"></a>- 案例：泰坦尼克号乘客生存预测</h2><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==titanic.ipynb==文件</strong></em></p><h2 id="5、随机森林"><a href="#5、随机森林" class="headerlink" title="5、随机森林"></a>5、随机森林</h2><ul><li>防止决策树出现过拟合</li><li>集成学习算法：建立几个模型组合解决单一预测问题，最后预测的结果取几个模型预测结果的众数</li><li>随机森林：包含<strong>多个决策树</strong>的分类器，结果由多个决策树结果的<strong>众数</strong>决定</li><li>两个随机：（保持每个决策树的独立）<ol><li><strong>训练集随机</strong><ul><li><strong>BootStrap抽样</strong>：在N个样本中随机有放回抽样抽N个，组成新训练集，抽到的新训练集可能有重复样本</li></ul></li><li><strong>特征随机</strong><ul><li>在M个特征中随机有放回抽样抽m个，组成新特征集，抽到的新特征集可能有重复特征（<strong>M&gt;&gt;m</strong>）</li><li><strong>优点</strong>：降维，运算速度快，防止过拟合，但不损失正确率</li></ul></li></ol></li></ul><p><strong>API：</strong></p><ul><li><p>sklearn.ensemble.RandomForestClassifier(参数)：</p><ul><li><strong>参数</strong>：<ul><li>n_estimators：树木数量，默认为10</li><li>criterion=：决策树划分依据，默认’gini’</li><li>max_depth=：树的深度大小，默认None</li><li>bootstrap=：是否随机有放回抽样，默认True</li><li>max_features=：每个决策树的最大特征数量<ul><li>‘auto’ 或 ‘sqrt’：m=sqrt(M)</li><li>‘log2’：m=log2(M)</li><li>None：m=M（一般不用）</li></ul></li><li>random_state=：随机数种子</li><li>…</li></ul></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>具有极好的准确率</li><li>适用于大数据场景，能处理高维特征的输入样本</li><li>能评估每个特征在分类问题上的重要性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习4——补充：数据预处理、转换器和预估器……</title>
      <link href="/2025/02/06/ji-qi-xue-xi-4-bu-chong-shu-ju-chu-li/"/>
      <url>/2025/02/06/ji-qi-xue-xi-4-bu-chong-shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</strong></p><hr><ul><li>深度学习 ⊆ <strong>机器学习</strong> ⊆ 人工智能<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是由机器学习发展而来</li></ul></li><li>应用领域：传统预测、图像识别、自然语言处理</li><li>理论书：《机器学习》“西瓜书”、《统计学习方法》</li><li>库：<strong>sklearn</strong></li><li>==<strong>模型选择</strong>==：<br><img src="https://s2.loli.net/2025/02/01/kAj2tX7rLOn5FMq.png" alt="image.png"></li></ul><h1 id="三、补充：数据预处理"><a href="#三、补充：数据预处理" class="headerlink" title="三、补充：数据预处理"></a>三、补充：数据预处理</h1><ul><li>数据分为：<ul><li>连续型数据：一个区间内可以取任意值（如：身高、体重等）</li><li>非连续型数据：只能取某些特定的值（如：性别、民族、血型等）</li></ul></li></ul><h2 id="1、去除唯一属性"><a href="#1、去除唯一属性" class="headerlink" title="1、去除唯一属性"></a>1、去除唯一属性</h2><ul><li>通常是一些id属性，不能表示数据本身的分布规律</li></ul><h2 id="2、处理缺失值"><a href="#2、处理缺失值" class="headerlink" title="2、处理缺失值"></a>2、处理缺失值</h2><h3 id="（1）方法"><a href="#（1）方法" class="headerlink" title="（1）方法"></a>（1）方法</h3><ul><li>直接使用含有缺失值的特征（适用于某个数据比较偏离原始的所有数据）</li><li>删除含有缺失值的特征（适用于某个特征含有大量缺失值、少量有效值，或含有的缺失值的数据数量相较于总体数据很少，删除影响不大）</li><li>缺失值插补：均值插补、同类均值插补、建模预测、高维映射、多重插补、手动插补、极大似然估计、压缩感知、矩阵补全</li></ul><h3 id="（2）缺失值插补方法"><a href="#（2）缺失值插补方法" class="headerlink" title="（2）缺失值插补方法"></a>（2）缺失值插补方法</h3><ul><li>均值插补：数据可度量-&gt;平均值，不可度量-&gt;众数</li><li>同类均值插补：先分类再用平均值插补</li><li>建模预测：将缺失值作为预测目标，利用现有的机器学习算法<ul><li><strong>缺点</strong>：如果其他属性与缺失值无关，则预测无效；如果相关，则没必要考虑缺失值；一般介于两者之间</li></ul></li><li>高维映射：用独热编码（one-hot编码）把属性映射到高维空间<ul><li><strong>优点</strong>：最精确</li><li><strong>缺点</strong>：计算量大，所需样本量大</li></ul></li><li>多重插补：将缺失值视为一个计算后的值加一个随机噪声，不同噪声得到多个插补值，根据实际情况选择合适的插补值</li><li>手动插补：主观估计插补值，需要符合现实规律<ul><li><strong>优点</strong>：效果比较好</li></ul></li></ul><h2 id="3、数据标准化"><a href="#3、数据标准化" class="headerlink" title="3、数据标准化"></a>3、数据标准化</h2><ul><li>将某个属性缩放到特定范围</li><li>原因：某些算法要求数据零均值、单位方差；<strong>消除不同属性不同量级的影响</strong></li><li>方法：<ul><li>min-max标准化（<strong>归一化</strong>）：将所有值映射到（0,1）上均匀分布，上下界映射为0、1</li><li>z-score标准化（<strong>规范化</strong>）：（原数据-均值）÷标准差，进行正态分布标准化</li></ul></li></ul><h1 id="四、sklearn转换器和预估器"><a href="#四、sklearn转换器和预估器" class="headerlink" title="四、sklearn转换器和预估器"></a>四、sklearn转换器和预估器</h1><ul><li>转换器（transformer）、预估器（estimator）</li><li><strong>转换器</strong>用于特征工程、特征处理，<strong>预估器</strong>用于调用模型、模型训练，注意区分！！！</li></ul><h2 id="1、转换器"><a href="#1、转换器" class="headerlink" title="1、转换器"></a>1、转换器</h2><ul><li><strong>特征工程处理</strong>第一步都要<strong>实例化</strong>一个转换器类，转换器可以看作特征工程方法的父类</li><li>fit_transform()：<ul><li>fit()：输入数据不处理，只计算每一列的均值和标准差</li><li>transform()：数据转换，利用fit()得到的均值和标准差计算</li></ul></li></ul><h2 id="2、预估器"><a href="#2、预估器" class="headerlink" title="2、预估器"></a>2、预估器</h2><ul><li>sklearn<strong>机器学习算法</strong>的实现，可以看作算法的父类</li><li>分类、回归、无监督学习的所有算法都是estimator的子类</li><li>步骤：<ol><li><strong>实例化</strong>一个预估器（算法）</li><li>训练，生成模型：调用 算法.fit(x_train , y_train)</li><li>模型评估：<ul><li>直接比对预测值与真实值：<ol><li>y_pred = 算法.predict(x_test)</li><li>y_test == y_pred ?</li></ol></li><li>直接计算准确率：<ul><li>accuracy = 算法.score(x_test, y_test)</li></ul></li></ul></li></ol></li></ul><h1 id="七、模型保存与加载"><a href="#七、模型保存与加载" class="headerlink" title="七、模型保存与加载"></a>七、模型保存与加载</h1><ul><li>导入库：import joblib<ul><li>joblib.dump(estimator , ‘xxx.pkl’)：保存模型</li><li>esti = joblib.load(‘xxx.pkl’)：加载模型</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信2：R 与 基因差异表达、GO富集</title>
      <link href="/2025/02/05/sheng-xin-2-r-yu-ji-yin-chai-yi-biao-da-go-fu-ji/"/>
      <url>/2025/02/05/sheng-xin-2-r-yu-ji-yin-chai-yi-biao-da-go-fu-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><strong>R语言是一种用于统计计算和图形生成的编程语言和操作环境，主要用于数据分析、统计建模以及制图。</strong></li><li><strong>基因差异表达和GO富集分析是生物信息学中用于分析高通量测序数据的两种重要方法，通常用于理解不同条件下基因表达的变化。</strong></li></ul><hr><h1 id="一、基础定义"><a href="#一、基础定义" class="headerlink" title="一、基础定义"></a>一、基础定义</h1><ul><li>R语言中的<strong>基础定义</strong>有：<ol><li>变量：在R中，可以使用赋值运算符（&lt;- 或者 =）来给变量赋值。变量名可以包含字母、数字、点和下划线，但不能以数字开头。</li><li>数据类型：R支持多种数据类型，包括数值型、字符型、逻辑型、复数等。</li><li>向量：向量是R中最基本的数据结构之一，是一维数组，可以存储相同类型的元素。可以用c()函数来创建一个向量。</li><li>矩阵：矩阵是二维的数据结构，所有元素必须是相同的类型。可以用matrix()函数创建。</li><li>数组：数组是多维的数据结构，与矩阵类似，但是可以有超过两维。</li><li>因子：因子是用于存储分类数据的向量，通常用于表示有限数量的不同组或类别。</li><li>列表：列表是一种复合数据结构，可以包含不同类型的对象，如向量、矩阵、列表等。</li><li>数据框：数据框类似于表格或电子表格，每一列可以包含不同类型的值，是R中用于存储和处理数据集的主要结构。</li><li>函数：R语言中的函数是一段可重复使用的代码块，用来执行特定任务。R自带了许多内置函数，并且用户也可以自定义函数。</li><li>包（Packages）：R的扩展库被称为包，它们提供了额外的功能，比如更复杂的统计分析工具或者图形界面。你可以通过install.packages()安装新的包，并用library()加载到当前会话中。</li></ol></li></ul><h1 id="二、基因差异表达、GO富集"><a href="#二、基因差异表达、GO富集" class="headerlink" title="二、基因差异表达、GO富集"></a>二、基因差异表达、GO富集</h1><ul><li><strong>基因差异表达</strong>是指在不同的实验条件或样本组之间比较基因表达水平，以识别那些表达显著变化的基因。</li><li>一旦找到了差异表达的基因列表，接下来就可以进行<strong>GO富集分析</strong>，以了解这些基因可能参与的生物学过程、分子功能和细胞组成成分。Gene Ontology（GO）是一个结构化的、受控的词汇表，描述了基因产品在生物学中的作用。</li></ul><h1 id="三、代码实例"><a href="#三、代码实例" class="headerlink" title="三、代码实例"></a>三、代码实例</h1><h2 id="0、准备"><a href="#0、准备" class="headerlink" title="0、准备"></a>0、准备</h2><ul><li>安装并载入所需的包：</li></ul><pre class="line-numbers language-R"><code class="language-R">#包的安装install.packages("BiocManager")library(BiocManager)BiocManager::install("DESeq2")install.packages("ggplot2")library(ggplot2)install.packages("pheatmap")library(pheatmap)install.packages("dplyr")library(dplyr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置工作目录：</li></ul><pre class="line-numbers language-R"><code class="language-R">#0. 设置当前工作目录setwd("xxx") # xxx为你设定的R的工作目录#查看工作目录getwd()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、画图"><a href="#1、画图" class="headerlink" title="1、画图"></a>1、画图</h2><ul><li>从外部读取数据：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 从外部读入数据rpkm<-read.table("rpkm.txt",header=T,row.names=1)head(rpkm,n=20)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>head：取数据的前n行，检查数据</em></p><ul><li>绘制箱线图：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 用读入的RPKM数据绘制箱线图rpkm<-read.table("rpkm.txt",header=T,row.names=1)boxplot(rpkm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/uOVfHTFpjXnhSPC.png" alt="image.png"></p><ul><li>美化箱线图：</li></ul><pre class="line-numbers language-R"><code class="language-R">log2(rpkm[,1][rpkm[,1]>0])->S0h1log2(rpkm[,2][rpkm[,2]>0])->S0h2boxplot(S0h1,S0h2,col=c("cyan","purple"),main="log2(RPKM)boxplot",names=c("S0h1","S0h2"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/yfhwa6v1Q4pPgTq.png" alt="image.png"></p><ul><li>绘制直方图：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 用读入的RPKM数据绘制直方图par(mfrow=c(1,2))hist(S0h1,breaks=100,main="log2(RPKM)histogram",col="blue")hist(S0h2,breaks=100,main="log2(RPKM)histogram",col="red")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/iIrD8s6kbh9LOS1.png" alt="image.png"></p><h2 id="2、相关性分析"><a href="#2、相关性分析" class="headerlink" title="2、相关性分析"></a>2、相关性分析</h2><ul><li>用R检验两重复样本的相关性：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 用R检验两重复样本的相关性log2(rpkm+1)->rpkmggplot(rpkm,aes(x=S0h1,y=S0h2))+geom_point(col="blue",cex=.6)+xlab("S0h1 log2(RPKM+1)")+ylab("S0h2 log2(RPKM+1)")->spmodel<-lm(S0h2~S0h1,rpkm)summary(model)sp+stat_smooth(method=lm,col="red",cex=1.1)+annotate("text",label="R^2==0.98",x=1,y=10,parse=TRUE)+theme_classic()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/17HEAy3lxNkmT5b.png" alt="image.png"></p><ul><li>用R画reads染色体分布图：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 用R画reads染色体分布图read.table("coverage.txt",header=T,sep="\t")->coveragehead(coverage)#将 coverage 数据框中的 chr 列转换为因子类型，并指定因子的水平为1到22号染色体，以及X和Y染色体coverage$chr<-factor(coverage$chr,levels=c(1:22,"X","Y")) p<-ggplot(coverage,aes(x=position,y=coverage,fill=chr))+  geom_bar(stat="identity",width=.5)+  ylab("Coverage")+  scale_fill_manual(values=rainbow(24))+  facet_grid(chr ~ .)+ #添加分面，按染色体分割图形，每个染色体一个面板  scale_y_continuous(breaks=c(0,3))+  xlab("Position")p# ggsave(filename="coverage_bar.png",plot=p,height=10,width=6.18) # 保存图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>ggsave( )是保存图片</em></p><p>输出图：<br><img src="https://s2.loli.net/2025/02/05/eHWOhK6tCzaFwLZ.png" alt="image.png"></p><h2 id="3、基因差异表达分析"><a href="#3、基因差异表达分析" class="headerlink" title="3、基因差异表达分析"></a>3、基因差异表达分析</h2><ol><li>用R筛选差异表达基因并绘制火山图：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 用R筛选差异表达基因并绘制火山图library("DESeq2") # 载入DESeq2包data <- read.table("genecount.txt")dim(data)head(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>预处理数据,去掉低表达的基因：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 预处理数据,去掉低表达的基因,只包含那些在至少一个样本中有表达的基因# rowSums(data)计算data数据框中每一行的和expressionData <- data[rowSums(data) >= dim(data)[2],] dim(expressionData)head(expressionData)expressionData <- expressionData+1head(expressionData)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建因子dex及元数据框：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 创建因子dex及元数据框dex <- factor(c(rep("L2",3),rep("L3",3)))meta <- data.frame(row.names=colnames(data),dex)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>创建DESeqDataSet对象：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 创建DESeqDataSet对象dds <- DESeqDataSetFromMatrix(countData = expressionData, colData = meta, design = ~ dex)dds <- DESeq(dds)res <- results(dds)head(res)res_1 <- data.frame(res)res_1 %>%  mutate(group =case_when(    log2FoldChange >= 2 & padj <=0.05 ~ "Up",    log2FoldChange <= -2 & padj <=0.05 ~ "Down",    TRUE ~ "Unchanged"  )) -> res_2table(res_2$group)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>画火山图：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 画火山图DEdata <- read.csv(paste('H1_vs_L1.bud.csv',sep = "."),header = T)dt <- data.frame(DEdata, stringsAsFactors = FALSE, check.names = FALSE)table(dt$group)dt$log10FDR <- -log10(dt$padj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>获取表达差异最显著的10个基因：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 获取表达差异最显著的10个基因；top10up <- filter(dt,group=="Up") %>% distinct(X,.keep_all = T) %>% top_n(10,abs(log2FoldChange))top10down <- filter(dt,group=="Down") %>% distinct(X,.keep_all = T) %>% top_n(10,abs(log2FoldChange))top10sig <- rbind(top10up,top10down)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>调整火山图：</li></ol><pre class="line-numbers language-R"><code class="language-R"># 新增一列，将Top10的差异基因标记为2，其他的标记为1；dt$size <- case_when(!(dt$X %in% top10sig$X)~ 1,dt$X %in% top10sig$X ~ 2)# 提取非Top10的基因表格；df <- filter(dt,size==1)# 指定绘图顺序,将group列转成因子型；df$group <- factor(df$group,levels = c("Up","Down","Unchanged"),ordered = T)# 自定义半透明颜色（红绿）；mycolor <- c("#FF99CC","#99CC00","gray80")p <- ggplot(data=df,aes(log2FoldChange,log10FDR,color=group))+  #-----------------------------geom_point(size=1.6)+  scale_colour_manual(name="",values=alpha(mycolor,0.7))+  geom_point(data=top10up,aes(log2FoldChange,log10FDR),color="#FF9999",size=3,alpha=0.9)+  geom_point(data=top10down,aes(log2FoldChange,log10FDR),color="#7cae00",size=3,alpha=0.9)+  labs(y="-log10FDR",title = 'H1_vs_L1')+  scale_y_continuous(expand=expansion(add = c(0, 0)))+  scale_x_continuous(limits = c(-10, 10))+  geom_hline(yintercept = c(-log10(0.05)),size = 0.7,color = "orange",lty = "dashed")+  geom_vline(xintercept = c(-2,2), size = 0.7,color = "orange",lty = "dashed")+  theme_classic()p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/l2ix3bCkaOUHcD7.png" alt="image.png"></p><h2 id="4、GO富集分析"><a href="#4、GO富集分析" class="headerlink" title="4、GO富集分析"></a>4、GO富集分析</h2><ul><li>用R进行聚类分析并作图：</li></ul><pre class="line-numbers language-R"><code class="language-R"># 用R进行聚类分析并作图data <- read.table("heatmap.txt",header=T,sep="\t",row.names=1)head(data)data.m = as.matrix(data)data.m = log2(data.m+0.01)pheatmap(data.m,          cluster_col = TRUE, # 如果是FALSE表示只对行进行聚类         clustering_distance_rows = "correlation",         scale="row",         colorRampPalette(c("green", "black", "red"))(100),         fontsize_row=6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出图：<br><img src="https://s2.loli.net/2025/02/05/6vfiNBX2RY8sdck.png" alt="image.png"></p><h2 id="5、线性拟合"><a href="#5、线性拟合" class="headerlink" title="5、线性拟合"></a>5、线性拟合</h2><ul><li>拟合并获取相关信息：</li></ul><pre class="line-numbers language-R"><code class="language-R">x <- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y <- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)relation <- lm(y ~ x)print(relation)summary(relation)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/FPdWYeMUlzHKE2q.png" alt="image.png"></p><ul><li>用ggplot画拟合图：</li></ul><pre class="line-numbers language-R"><code class="language-R">library(ggplot2)data <- data.frame(weight = y, Height = x)ggplot(data, aes(x = weight, y=Height))+  geom_point(color = "blue", size = 3)+  geom_smooth(method = "lm", color = "red", se = FALSE)+  labs(title = "Height & Weight Regression",       x = "Weight in Kg", y = "Height in cm")+  theme_classic()a <- data.frame(x = 170)result <- predict(relation, a)print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/02/05/5PniRVSheDzBZOK.png" alt="image.png"><br><img src="https://s2.loli.net/2025/02/05/r6qtBERTk5AlcSZ.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> 基因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习3——特征工程</title>
      <link href="/2025/02/05/ji-qi-xue-xi-3-te-zheng-gong-cheng/"/>
      <url>/2025/02/05/ji-qi-xue-xi-3-te-zheng-gong-cheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</strong></p><hr><ul><li>深度学习 ⊆ <strong>机器学习</strong> ⊆ 人工智能<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是由机器学习发展而来</li></ul></li><li>应用领域：传统预测、图像识别、自然语言处理</li><li>理论书：《机器学习》“西瓜书”、《统计学习方法》</li><li>库：<strong>sklearn</strong></li><li>==<strong>模型选择</strong>==：<br><img src="https://s2.loli.net/2025/02/01/kAj2tX7rLOn5FMq.png" alt="image.png"></li></ul><h1 id="二、特征工程"><a href="#二、特征工程" class="headerlink" title="二、特征工程"></a>二、特征工程</h1><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==feature_engineering.py==文件</strong></em></p><ul><li>训练集和测试集所进行的特征工程应该是相同的，所以<strong>对x_test进行特征工程应该用x_train的特征工程处理方法</strong>，而不是单独对x_test进行又一次特征工程！</li><li><strong>同时对一个DataFrame进行多个特征工程操作：sklearn.compose.ColumnTransformer（注意API的中括号与小括号使用）</strong></li></ul><h2 id="1、数据集"><a href="#1、数据集" class="headerlink" title="1、数据集"></a>1、数据集</h2><h3 id="（1）可用数据集"><a href="#（1）可用数据集" class="headerlink" title="（1）可用数据集"></a>（1）可用数据集</h3><ul><li>来源：<ul><li>平时：<ul><li>公司内部</li><li>数据接口</li><li>机构内部</li></ul></li><li>学习：<ul><li><strong>sklearn</strong>自带少量数据集</li><li><strong>kaggle</strong>大量数据集</li><li>UCI 收集的数据集</li><li>阿里云的<strong>天池</strong>数据集</li></ul></li></ul></li></ul><h3 id="（2）Sklearn数据集"><a href="#（2）Sklearn数据集" class="headerlink" title="（2）Sklearn数据集"></a>（2）Sklearn数据集</h3><ul><li>Scikit-learn，Python的机器学习库<ul><li>包含：分类、聚类、回归、特征工程、模型选择与调优</li></ul></li></ul><h4 id="①数据集"><a href="#①数据集" class="headerlink" title="①数据集"></a>①数据集</h4><ul><li>sklearn.datasets（需要import导入）</li><li>获取方法：<ul><li>datasets.load_数据集名字()：<strong>获取小规模数据集</strong>，sklearn自带<ul><li>例如：sklearn.datasets.load_iris()，获取鸢尾花数据集</li></ul></li><li>datasets.fetch_数据集名字(data_home=数据集下载的目录 , subset= )：<strong>获取大规模数据集</strong>，需要从网上下载，data_home默认为 ./scikit_learn_data/，subset（可省略）选择需要加载的数据集，有’train’、’test’、’all’</li></ul></li></ul><h4 id="②使用"><a href="#②使用" class="headerlink" title="②使用"></a>②使用</h4><ul><li>load和fetch返回的都是Bunch类型的数据（继承自字典）<ul><li>键-值对：<ul><li>data：特征值</li><li>target：标签值</li><li>DESCR：数据集的描述</li><li>feature_names：特征值的名字</li><li>target_names：标签值的名字</li></ul></li><li>获取属性：<ul><li>bunch[‘key’] = value</li><li>bunch.key = value</li></ul></li></ul></li></ul><h4 id="③-划分"><a href="#③-划分" class="headerlink" title="③==划分=="></a>③==划分==</h4><ul><li>数据不能全部用来训练，需要有<strong>测试数据集</strong></li><li>分为：<ol><li>训练数据：构建模型（70~80%）</li><li>测试数据：评估模型（20~30%）</li></ol></li><li>sklearn.model_selection.train_test_split(特征值 , 标签值 , test_size= , random_state= )<ul><li>参数（可省略）：<ul><li>test_size=：测试集的大小比例（如：0.2，默认 0.25）</li><li>random_state=：随机数种子，不同的采样</li></ul></li><li>return：训练集特征值、测试集特征值、训练集标签值、测试集标签值（<em>注意顺序</em>，可以起名：<strong>x_train、x_test、y_train、y_test</strong>）</li></ul></li></ul><h2 id="2、特征工程介绍"><a href="#2、特征工程介绍" class="headerlink" title="2、特征工程介绍"></a>2、特征工程介绍</h2><ul><li>处理数据，使特征能在算法中发挥更好的作用</li><li>工具：<ul><li>sklearn：特征工程</li><li>pandas：数据清洗、数据处理</li></ul></li></ul><h2 id="3、特征提取"><a href="#3、特征提取" class="headerlink" title="3、特征提取"></a>3、特征提取</h2><ul><li>将任意数据（如文本、图像等）转换成可用于机器学习算法的数字特征（特征值化）<ul><li>字典特征提取（特征离散化）</li><li>文本特征提取</li><li>图像特征提取（深度学习）</li></ul></li></ul><h3 id="（1）对字典特征提取"><a href="#（1）对字典特征提取" class="headerlink" title="（1）对字典特征提取"></a>（1）对字典特征提取</h3><ul><li>类别 -&gt; <strong>one-hot编码</strong></li><li>sklearn.feature_extraction.DictVectorizer(sparse= )<ul><li>one-hot编码需要<strong>sparse=False</strong>，默认<strong>sparse=True</strong>（也可以sparse=True并对返回的矩阵.<strong>toarray</strong>()，输出one-hot编码矩阵）</li><li>DictVectorizer.fit_transform(data)<ul><li>data为<strong>字典的可迭代对象</strong></li><li>return：<ul><li>sparse=True -&gt; sparse矩阵（稀疏矩阵）：将非零值用位置表示，节省内存</li><li>sparse=False -&gt; one-hot编码的矩阵</li></ul></li></ul></li><li>DictVectorizer.get_feature_names_out()：获取每一列的名字</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'北京'</span><span class="token punctuation">,</span><span class="token string">'temperature'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'上海'</span><span class="token punctuation">,</span><span class="token string">'temperature'</span><span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token string">'city'</span><span class="token punctuation">:</span> <span class="token string">'深圳'</span><span class="token punctuation">,</span><span class="token string">'temperature'</span><span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 数据要是字典的迭代器，可以列表包含字典</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 1、实例化一个转换器类：</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> trans <span class="token operator">=</span> DictVectorizer<span class="token punctuation">(</span>sparse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># one-hot编码需要sparse=False</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 2、调用fit_transform()</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> data_new <span class="token operator">=</span> trans<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"new data:\n"</span><span class="token punctuation">,</span> data_new<span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"feature names:\n"</span><span class="token punctuation">,</span> trans<span class="token punctuation">.</span>get_feature_names_out<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的one-hot编码的矩阵：<br><img src="https://s2.loli.net/2025/01/21/2XqvH8BzCMdmGIj.png" alt="image.png"></p><ul><li>应用场景：<ul><li>数据集的类别特征多<ol><li>特征 -&gt; 字典类型</li><li>DictVectorizer</li></ol></li><li>拿到的数据是字典类型</li></ul></li></ul><h3 id="（2）对文本特征提取"><a href="#（2）对文本特征提取" class="headerlink" title="（2）对文本特征提取"></a>（2）对文本特征提取</h3><ul><li>单词作为特征（特征词）</li></ul><h4 id="①提取特征词次数"><a href="#①提取特征词次数" class="headerlink" title="①提取特征词次数"></a>①提取特征词次数</h4><ul><li>sklearn.feature_extraction.text.CountVectorizer()<ul><li>可省略参数：stop_words=[ ]（不统计的词）</li><li>DictVectorizer.fit_transform(data)<ul><li>data为<strong>文本或字符串的可迭代对象</strong></li><li>return：sparse矩阵（sparse矩阵.<strong>toarray</strong>()，输出one-hot编码矩阵）</li></ul></li><li>return：词频矩阵（单词计数，且去掉字母等无关紧要的字符）<br><strong>英文</strong>文本：</li></ul></li></ul><pre class="line-numbers language-python"><code class="language-python">text <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"life is short,i like like python"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token string">"life is too long,i dislike python"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 类似dict_demo()</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> trans <span class="token operator">=</span> CountVectorizer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> text_new <span class="token operator">=</span> trans<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># print("new text:\n", text_new) # 返回sparse矩阵，不方便观察</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"new text:\n"</span><span class="token punctuation">,</span> text_new<span class="token punctuation">.</span>toarray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"feature names:\n"</span><span class="token punctuation">,</span> trans<span class="token punctuation">.</span>get_feature_names_out<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的one-hot编码的矩阵：<br><img src="https://s2.loli.net/2025/01/21/KXHOnYlbDpT6Lzx.png" alt="image.png"></p><p><em>如果是<strong>中文</strong>文本，导入<strong>jieba（结巴）库</strong>，用jieba自动分词后再进行类似英文的文本特征提取（见文件）</em></p><h4 id="②提取关键词"><a href="#②提取关键词" class="headerlink" title="②提取关键词"></a>②提取关键词</h4><ul><li><p><strong>关键词</strong>：在某一文章中出现多次，其他文章中出现很少，适合用来文章分类</p></li><li><p><strong>Tf-idf</strong>：</p><ul><li>Tf：词频，某个词在给定文章中出现的频率<ul><li>Tf = 该文章中词语出现次数/该文章的总词数</li></ul></li><li>idf：逆向文档频率，一个词的普遍重要性的度量<ul><li>idf = lg(语料库中的文章总数 / (含有该词的文章总数+1 ))</li></ul></li><li>Tf-idf = Tf × idf，可以理解为某词在某文章中的重要程度</li></ul></li><li><p>sklearn.feature_extraction.text.TfidfVectorizer()</p><ul><li>可省略参数：stop_words=[ ]（不统计的词）</li><li>TfidfVectorizer.fit_transform(data)<ul><li>data为<strong>文本或字符串的可迭代对象</strong></li><li>return：sparse矩阵（sparse矩阵.<strong>toarray</strong>()，输出one-hot编码矩阵）</li></ul></li><li>return：词的权重矩阵（数字越大越重要）</li></ul></li></ul><h2 id="4、特征预处理"><a href="#4、特征预处理" class="headerlink" title="4、特征预处理"></a>4、特征预处理</h2><ul><li>将原始特征数据转换成更适合算法模型的特征数据</li><li>数值型数据的无量纲化：<strong>避免特征间量级的支配影响</strong><ul><li>归一化</li><li>标准化</li></ul></li><li>sklearn.preprocessing</li></ul><h3 id="（1）归一化"><a href="#（1）归一化" class="headerlink" title="（1）归一化"></a>（1）归一化</h3><ul><li><p>将数据映射到一个区间内（默认 [0 , 1] 区间）<br><img src="https://s2.loli.net/2025/01/21/MxNwbIK5Szrhe8f.png" alt="image.png"></p></li><li><p>sklearn.preprocessing.MinMaxScaler(feature_range= )</p><ul><li>feature_range=：映射到的区间，默认为(0 , 1)</li><li>MinMaxScaler.fit_transform(data)<ul><li>data的格式必须为：ndarray，形状 [样本数 , 特征数]</li><li>return：映射后形状相同的ndarray</li></ul></li></ul></li><li><p><strong>缺点</strong>：异常值一般是最大值、最小值，所以归一化易受影响，<strong>鲁棒性（稳定性）较差</strong>（只适合传统精确小数据）</p></li></ul><h3 id="（2）标准化"><a href="#（2）标准化" class="headerlink" title="（2）标准化"></a>（2）标准化</h3><ul><li><p>将数据正态标准化为均值为0，标准差为1的范围内<br><img src="https://s2.loli.net/2025/01/22/Q6gt2fbV79UDewI.png" alt="image.png"></p></li><li><p>sklearn.preprocessing.StandardScaler()</p><ul><li>每列数据转换为均值为0，标准差为1</li><li>StandardScaler.fit_transform(data)<ul><li>data的格式必须为：ndarray，形状 [样本数 , 特征数]</li><li>return：转换后形状相同的ndarray</li></ul></li></ul></li><li><p><strong>优点</strong>：对于有一定数据量的数据集来说，异常值对标准化的影响不大，<strong>比较稳定</strong>（适合现代嘈杂的大数据环境）</p></li></ul><h2 id="5、特征降维"><a href="#5、特征降维" class="headerlink" title="5、特征降维"></a>5、特征降维</h2><ul><li>对样本特征矩阵 [样本数 , 特征数] 降维，<strong>降低特征个数（列数）</strong>，特征数就是维度数</li><li><strong>效果：特征与特征之间不相关</strong><ul><li>相关特征：如 降雨量与相对湿度</li><li>不相关特征：减少冗余信息</li></ul></li></ul><h3 id="（1）特征选择"><a href="#（1）特征选择" class="headerlink" title="（1）特征选择"></a>（1）特征选择</h3><ul><li>从原有特征中找出主要特征</li><li>sklearn.feature_selection</li></ul><h4 id="①Filter过滤式"><a href="#①Filter过滤式" class="headerlink" title="①Filter过滤式"></a>①Filter过滤式</h4><ul><li>方法：<ul><li><p>方差选择法：过滤掉所有小方差特征</p><ul><li>sklearn.feature_selection.VarianceThreshold(threshold= )<ul><li>threshold= ：过滤的方差阈值，默认为0</li><li>VarianceThreshold.fit_transform(data)<ul><li>data的格式必须为：ndarray，形状 [样本数 , 特征数]</li><li>return：删除低方差特征后的ndarray</li></ul></li></ul></li></ul></li><li><p>相关系数法：过滤掉相关性大的特征（ | r | 接近1）</p><ul><li>皮尔逊相关系数：<br>  <img src="https://s2.loli.net/2025/01/22/nfza3XqMEC4k1gu.png" alt="image.png"></li><li>from scipy.stats import pearsonr<ul><li>pearsonr(feat1 , feat2)<ul><li>feat1、2都是特征列</li><li>return：（相关系数，P_值）（P_越小相关性越大、越显著）</li></ul></li></ul></li><li>得到的相关性很高的特征：<ul><li>只选择其中一个</li><li>加权求和作为新特征替代</li><li>主成分分析</li></ul></li></ul></li></ul></li></ul><h4 id="②Embeded嵌入式"><a href="#②Embeded嵌入式" class="headerlink" title="②Embeded嵌入式"></a>②Embeded嵌入式</h4><ul><li>方法：<ul><li>决策树（见后面章节）</li><li>正则化（见后面章节）</li><li>深度学习</li></ul></li></ul><h3 id="（2）主成分分析"><a href="#（2）主成分分析" class="headerlink" title="（2）主成分分析"></a>（2）主成分分析</h3><ul><li><strong>PCA</strong>，高维数据 -&gt; 低维数据，可能涉及舍弃数据、增加变量</li><li><strong>作用</strong>：降低维数（复杂度），同时减少信息损失</li><li>应用：回归分析、聚类分析</li><li>找到合适的直线，根据投影得出主成分分析结果</li><li>sklearn.decomposition.PCA(n_components= )<ul><li>n_components= ：<ul><li><strong>小数</strong>：保留百分之多少的信息</li><li><strong>整数</strong>：减少到多少特征</li></ul></li><li>PCA.fit_transform(data)<ul><li>data的格式为：二维数组，形状 [样本数 , 特征数]</li><li>return：降维后指定维数（特征数）的ndarray</li></ul></li></ul></li></ul><h3 id="案例：Instacart市场篮子分析（数据处理部分）"><a href="#案例：Instacart市场篮子分析（数据处理部分）" class="headerlink" title="- 案例：Instacart市场篮子分析（数据处理部分）"></a>- 案例：Instacart市场篮子分析（数据处理部分）</h3><p><em><strong>具体代码见Python&gt;MachineLearning文件中的==instacart.ipynb==文件</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习2——基本概念</title>
      <link href="/2025/02/04/ji-qi-xue-xi-2-ji-ben-gai-nian/"/>
      <url>/2025/02/04/ji-qi-xue-xi-2-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</strong></p><hr><ul><li>深度学习 ⊆ <strong>机器学习</strong> ⊆ 人工智能<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是由机器学习发展而来</li></ul></li><li>应用领域：传统预测、图像识别、自然语言处理</li><li>理论书：《机器学习》“西瓜书”、《统计学习方法》</li><li>库：<strong>sklearn</strong></li><li>==<strong>模型选择</strong>==：<br><img src="https://s2.loli.net/2025/02/01/kAj2tX7rLOn5FMq.png" alt="image.png"></li></ul><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><ul><li>机器学习：Machine Learning（ML）<ul><li>定义：从<strong>数据</strong>中自动分析获得<strong>模型</strong>（规律），并利用模型对未知数据进行<strong>预测</strong>（解决问题）</li></ul></li><li>==<strong>算法</strong>==是核心，<strong>数据</strong>和<strong>计算</strong>是基础</li></ul><h2 id="1、数据集的构成"><a href="#1、数据集的构成" class="headerlink" title="1、数据集的构成"></a>1、数据集的构成</h2><ul><li>结构：特征值+标签值（不一定有）<br><img src="https://s2.loli.net/2025/01/20/y5v6fATGs3p7Ld8.png" alt="image.png"><br><em>↑通过前四列特征值（x），预测最后一列标签值（y）</em><br><em>每一行称为样本</em><br><em>有些数据集可以没有标签值（聚类、分类）</em></li></ul><h2 id="2、算法的分类"><a href="#2、算法的分类" class="headerlink" title="2、算法的分类"></a>2、算法的分类</h2><ul><li><p>按照<strong>标签值</strong>是：</p><ul><li>类别：分类问题</li><li>连续型数据：回归问题</li><li>无：无监督学习</li></ul></li><li><p>分为==<strong>监督学习（supervised learning）和无监督学习（unsupervised learning）</strong>==</p><ul><li>监督学习：==分类、回归（有特征值、<strong>有标签值</strong>）==</li><li>无监督学习：==聚类（有特征值、<strong>无标签值</strong>）==</li></ul></li><li><p>算法：</p><ul><li>监督学习（预测）：<ul><li>分类问题：<strong>k-近邻算法、贝叶斯算法、决策树与随机森林、逻辑回归</strong></li><li>回归问题：<strong>线性回归、岭回归</strong></li></ul></li><li>无监督学习：<ul><li>聚类：<strong>k-means</strong></li></ul></li></ul></li></ul><h2 id="3、开发流程"><a href="#3、开发流程" class="headerlink" title="3、开发流程"></a>3、开发流程</h2><ol><li>获取数据</li><li>数据处理</li><li>特征工程</li><li>机器学习算法训练，得到模型</li><li>模型评估（必要时返回第二步再逐步修改）</li><li>实际应用<br><img src="https://s2.loli.net/2025/01/20/jRITXwUtS7LmfHr.png" alt="image.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物化学代谢</title>
      <link href="/2025/02/02/sheng-hua-dai-xie/"/>
      <url>/2025/02/02/sheng-hua-dai-xie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>生物化学课程代谢反应的特征总结，从产物、过程等特征来总结相关反应式。</strong></p><hr><ul><li><p>生成PPi的反应：</p><ul><li>生成UDP-G（活性葡萄糖，UTP脱PPi）</li><li>脂酸 + CoA + ATP -&gt; 脂酰~CoA + AMP + PPi</li><li>氨基酸 + ATP&nbsp;-&gt; 氨基酰~AMP + PPi（氨基酸的活化）</li><li>脂酰CoA的形成（脂肪酸的活化）</li><li>CDP-含氮碱的合成（CTP脱PPi）</li><li>瓜氨酸+天冬氨酸 -&gt; 精氨酸代琥珀酸</li><li>嘌呤碱合成第一步</li><li>嘧啶碱合成第五步</li><li>DNA复制5′至3′的聚合</li><li>两段DNA之间的连接（DNA复制）</li><li>氨基酰-tRNA的合成（翻译）</li><li>尿素合成总方程式</li></ul></li><li><p>底物水平磷酸化：</p><ul><li>1,3-二磷酸甘油醛 -&gt; 3-磷酸甘油醛（磷酸甘油酸激酶，糖酵解）</li><li>磷酸烯醇式丙酮酸 -&gt; 丙酮酸（丙酮酸激酶，糖酵解）</li><li>琥珀酰CoA -&gt; 琥珀酸（琥珀酰CoA合成酶，TCA）</li></ul></li><li><p>重要反应循环：</p><ul><li>糖酵解</li><li>TCA</li><li>糖异生</li><li>脂肪酸代谢</li><li>氨基酸代谢</li><li>尿素循环</li></ul></li><li><p>不可逆反应：</p><ul><li>G -&gt; G-6-P（糖酵解1）</li><li>F-6-P的磷酸化成F-1,6-P（糖酵解3）</li><li>PEP生成丙酮酸（糖酵解10）</li><li>丙酮酸生成乙酰CoA（有氧部分第一步）</li><li>乙酰CoA与草酰乙酸生成柠檬酸（TCA1）</li><li>α-酮戊二酸生成琥珀酰CoA（TCA4）</li><li><del>延胡索酸生成苹果酸（TCA7）</del></li></ul></li><li><p>氧化脱羧：</p><ul><li>丙酮酸&nbsp; → 乙酰CoA</li><li>异柠檬酸生成α-酮戊二酸（TCA3）</li><li>α-酮戊二酸生成琥珀酰CoA（TCA4）</li></ul></li><li><p>FAD参与的反应：</p><ul><li>琥珀酸生成延胡索酸（TCA6）</li><li>脂酰CoA脱氢生成烯脂酰CoA（β氧化1）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《文明之旅》1011-1020年</title>
      <link href="/2025/01/31/wen-ming-zhi-lu-1011-1020-nian/"/>
      <url>/2025/01/31/wen-ming-zhi-lu-1011-1020-nian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>这是一档聚焦中国历史，计划持续二十年制作播出的视频节目，也是一个超长期的文化工程。它将传承《资治通鉴》的中国编年史传统，从公元1000年开讲，一直讲到1912年，每一期节目聚焦于中国历史上的一年。上下913期节目，前后20年的时光，将陪伴和影响不止一代人。</strong></p><hr><h3 id="1011"><a href="#1011" class="headerlink" title="1011"></a>1011</h3><ul><li><strong>古人为什么会乱花钱？</strong></li><li>宋真宗花大钱祭祀汾阴。真宗为什么有钱花？宋辽战争停息有大量预算省出来（因为战争让税收达到高峰）。真宗其实尊重预算，且觉得封禅祭祀和赏赐百姓是应该做的。当代人有意义的花钱是在当下节省、对未来投资，观念基础是未来会更好，财富持续增长。而传统农耕社会基于循环史观，不相信财富会持续增长，不投资未来，只注重当下。古代天子花钱只有四条路：声色犬马、穷兵黩武、大兴土木、迷信活动（最无害的一种）。（对一个企业来说）有多余的钱，就会干多余的事。《富种起源》把产品分两类：生存品（生存刚需）、效用品（带来情绪价值）。有时候，效用品常常比生存品还重要，且效用品会不断进化迭代。例子：公孔雀的屏（性选择理论、费舍尔失控）。竞争、攀比等（内卷？）会把生存品变成效用品，把效用推到极致。分清需求和欲望！需求类似生存品，欲望类似效用品，不能没有，但也不能纵容。</li></ul><h3 id="1012"><a href="#1012" class="headerlink" title="1012"></a>1012</h3><ul><li><strong>大宋为什么歧视南方人？</strong></li><li>北宋初年不让南方人当宰相，为什么歧视南方人？①方言问题，北方听不懂。②宋朝本来就是北方人创立。③北方人可能认为南方人太投机，人品不好。④北方潜意识里怕竞争不过南方人，管不住南方人。其实北宋初年所谓南方人主要是指南唐遗民、遗臣，因为南唐实力其实很强，是块硬骨头，而且自称继承唐朝，有政权正统问题，还存在宋朝对南唐的经济文化自卑。什么是历史的灾难？就是把人浪费掉，人们不能干他们最喜欢最适合的事。而南唐没有把人浪费掉，反而致力于把文化的种子流传下去。每个乱世都有文明的火种罐，比如春秋的鲁国、南北朝的江东、五代十国的南唐、西方的希腊文明等，外面的战乱挡不住里面的繁华，一旦和平到来，文明立刻星火燎原。历史界有一种观点，认为发生在四十年内的不叫历史，叫交往记忆，因为当事人还在，四十年以后被固化成文字才叫历史。（刘禹锡，乐观积极的态度）</li></ul><h3 id="1013"><a href="#1013" class="headerlink" title="1013"></a>1013</h3><ul><li><strong>明知宦官里有小人，为何非用不可？</strong></li><li>造神像。宦官位卑权大，经常自作主张胡作非为。虽然不好，但是皇帝因为信任问题只能任用宦官，因为宦官已经没有社会身份了。所以宦官越来越多，他们可以替皇帝探听消息，也能靠身份做监军等监督职位。权力其实与信息流挂钩，官僚制度最好设置做事的和监察的两个部门。宋朝皇帝上朝：前殿视朝、后殿再坐、经筵、内引奏事、禁中夜对、转对/轮对，旨在落实兼听则明原则。宦官提供的关键信息能帮助皇帝做决策，信息交叉验证。大臣也会利用这种机制与皇帝进行信息博弈。（马克-斯托金，考古交叉验证，推出人类褪去体毛的时间）</li></ul><h3 id="1014"><a href="#1014" class="headerlink" title="1014"></a>1014</h3><ul><li><strong>杨家将传说到底有几分真？</strong></li><li>宋真宗力不从心，用的大臣都是老臣。杨延昭去世。杨家将的真实性占比?杨家将三代：杨业，杨延昭，杨文广。民间关于杨家将的故事大部分是虚构的。口语文化，区别于信史。在口语时代（文字不普及），文化传播规模大，传播力强（例如各文明的史诗），一代代人口口相传。关于史诗：帕里-诺德理论（人们通过各种套路、套话编织出长故事）。口语时代的人记诵能力强，现代人因为进入了电子时代不需要大段背诵的能力，能力逐渐消退。口语时代的人真实和虚构界限模糊，口口相传会叠加自己的想象。文字文化的白纸黑字带来确定性，也就有了标准答案，这是口语文化没有的。文字文化中的人生活在别处，统一的标准是由远方的人定的；而口语文化的人生活在附近，生活的标准由周围的人校正，只在乎自己生活的附近。口口相传的传说一旦写成定本，它精彩绝伦的口语变化就消失了，只能舍弃自由发挥的想象。口语文化为即兴发挥、文字创造力留下空间。说书人关注的是观众，而不是是否按照书本准确地讲。听书、听剧其实是在参与这场游戏，每个人都在见证每场的不一样。（口语传播者）</li></ul><h3 id="1015"><a href="#1015" class="headerlink" title="1015"></a>1015</h3><ul><li><strong>5次罢相，寇准一生为何大起大落？</strong></li><li>寇准第四次被贬。现实中寇准其实豪奢，和传说有出入。寇准因为年轻，深受大臣和皇帝的喜爱，前半段仕途顺利。其实是宋太宗有意提拔科举进士，想打造大臣班底。寇准是孤臣，不党，符合宋太宗的期望，但也因为这种我行我素的性格被贬多次，他二十年性格上没有成长。二十岁以后成长是在社会网络中的，向周围网络输出秩序。成长不能忽视社会网络关系。</li></ul><h3 id="1016"><a href="#1016" class="headerlink" title="1016"></a>1016</h3><ul><li><strong>宋朝宰相名为什么这么怪？</strong></li><li>宋真宗终于停止搞封建迷信了。北宋前期宰相官名是，同中书门下平章事。宰相的称号很乱。同：暂代、等同，中书门下：中书省、门下省，平：辨别，章：彰显，事：国家大事。唐朝中期开始，真正的宰相头衔有名无实，同中书门下平章事成了真宰相。古代官制三个逻辑：一、破格提拔资历浅的人，因为资历老的难管，他们用来削弱老资历大臣的权利。二、分拆，宰相拆成中书（起草）、尚书（执行）、门下省（审核），宰相共同决策，而不是一人专权。三、临时性差遣替代正式官职，方便处理事。这种非正式制度目的是找到皇帝与宰相的平衡，让宰相既不以下犯上，又有行政高效率。正式制度与非正式制度共存，让国家行政管理更有弹性，具体情况具体实行，实事求是。（费孝通：双轨政治，正式规则+民间规则）真正做事的人，会坚持大纲推动目标，又根据需要创设权宜之计。</li></ul><h3 id="1017"><a href="#1017" class="headerlink" title="1017"></a>1017</h3><ul><li><strong>如何拥有被讨厌的勇气？</strong></li><li>宰相王旦去世，谥号文贞（文正）。王旦正好赶上崇文抑武的时代红利，父亲王祜关系网好。王旦不存私心，他把权利和责任的界限划分的清清楚楚，该做什么就做什么。课题分离：只操心自己的事，谁承担后果就是谁的事。（《被讨厌的勇气》）正办：事情在此情此景下最正大光明、理应如此的处理方法。不会处理事情时以诚相待，虽不能占到便宜，也不至于过于吃亏。即使吃亏，后面挽回损失。尊重规则，并帮助人，该怎么办就怎么办。（阿德勒的生活哲学）</li></ul><h3 id="1018"><a href="#1018" class="headerlink" title="1018"></a>1018</h3><ul><li><strong>科举到底是一种怎样的全民游戏？</strong></li><li>宋真宗要立太子。“书中自有黄金屋，书中自有颜如玉”，《劝学诗》不是宋真宗写的，这首诗不符合儒家价值观。把它归为宋真宗写的，是早期印刷文化的乱象。宋真宗把科举平民化。有领导力的人，不是统一共识，而是统一目标。朝廷放出少量官位，却让全国读书人上瘾，就想现在的游戏。游戏的底层逻辑是随机奖励（斯金纳的盒子），随机奖励带来沉迷效应。且成长路径十分清楚，确定性强。科举也一样，所以科举是一个全民共识的政治制度，允许任何人带着自己的理解参与进来。科举可以让老人也看到考取功名的希望，让所有读书人看到稳步上升的台阶。哪怕只中秀才，社会地位也会提升，声望也会提高。现代教育相对科举而言，投入成本提高，成果确定性降低。一个成功的制度会直面参与者的欲望，能接纳各种价值观的人。（蒲松龄，私塾先生）</li></ul><h3 id="1019"><a href="#1019" class="headerlink" title="1019"></a>1019</h3><ul><li><strong>文坛宗师是怎么掉队的？</strong></li><li>杨亿，宋真宗时代的文坛盟主，创立了诗歌当中的西昆体（《西昆酬唱集》）。西昆体现代的评价偏负面，但是在北宋当时备受好评，风靡一时。杨亿从小就是神童，神童好处是可以结交朝中重臣，陪太子读书获得信任，以后可以给皇上当秘书，也经常成为科举主考官。杨亿影响文坛除了做科举主考官提携后辈，还有编大书传后世。杨亿为人顽固任性，但所有人都宠着他。西昆体特点：做工精细，辞藻华丽，堆砌典故（学李商隐“獭祭鱼”），所以当代人（特别是钱钟书）对他的评价很差。西昆体在当时受到追捧，是因为宋真宗想营造一个太平盛世的文风，当时人就喜欢这种写法。也因为当时文人有酬唱需要，有竞争性，所以以西昆体为标准，看谁掌握的典故多，谁学问就大。成为大师需要有深入的对话对象，不取决于他的才能和机遇，而是探寻深处的永恒话题。（钱钟书《宋诗选注》，有自己的选择标准）</li></ul><h3 id="1020"><a href="#1020" class="headerlink" title="1020"></a>1020</h3><ul><li><strong>寇准做对了什么关键选择？</strong></li><li>大宦官周怀政政变，结果失败被处决，寇准一派被牵连，刘皇后和丁谓一派胜利。寇准前一年献天书得以当宰相，可能这件事其实是皇帝主动启用寇准，为了确保皇位交接，防范刘皇后。寇准能抗责任，能断大事，但是与大臣们的关系不好，尤其是丁谓从朋友变政敌，且做事大大咧咧。周怀政害怕失宠，发动政变，但是很快失败。寇准一贬再贬，直到在雷州去世，后来形象在民间不断美化。人非圣贤，孰能无过，有缺点的普通人也能成为圣贤一样的人。寇准政治上的抉择，都是在文明的时间尺度上，只做对的、符合道德原则的事，而不是根据利益来选择，后世的美名是文明对他选择的报答，文明选择性遗忘了他的缺陷。历史有时候为了真善美，会隐藏真实，牺牲真实，制造真实。这是礼教的作用，在塑造所有人，带来文明共识。礼教给历史评判带来标准，做事不问可不可能，但问应不应该。（诗人寇准，七言绝句）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《文明之旅》 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生信1：Numpy + Pandas</title>
      <link href="/2025/01/30/sheng-xin-1-numpy-pandas/"/>
      <url>/2025/01/30/sheng-xin-1-numpy-pandas/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>生物信息学是一门以生物学、数学和信息科学为基础的交叉学科，它通过综合运用数学和信息科学等多领域的方法和工具对生物信息进行获取、加工、存储、分析和解释，来阐明大量生物数据所包含的生物学意义。</li><li>这里的Pandas只作最简单的介绍，详细使用见另一篇文章<strong>Pandas</strong>！</li></ul><hr><center> 所有代码均用Jupyter实现</center> <h1 id="一、numpy"><a href="#一、numpy" class="headerlink" title="一、numpy"></a>一、numpy</h1><h2 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><ul><li>NumPy是Python编程语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</li><li>NumPy的主要对象是一个叫做ndarray的同质多维数组，即一个所有元素类型相同、且在内存中连续存储的表格，可以通过一组N个正整数来索引。</li></ul><h2 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h2><h3 id="①创建对象"><a href="#①创建对象" class="headerlink" title="①创建对象"></a>①创建对象</h3><p>Numpy数组是一个多维数组对象，称为ndarray，它由两部分组成：</p><ul><li>实际的数据</li><li>描述这些数据的元数据</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 多维数组ndarray</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npar <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 输出数组，注意数组的格式：中括号，元素中间没有逗号（和列表区分）</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出数组维度的个数（轴数），或者说“秩”，维度的数量也称 rank</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 数组的维度，对于n行m列的数组，shape为（n，m）</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>size<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 数组的元素总数，对于n行m列的数组，元数总数为n*m</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 数组中元素的类型，类似type()（注意：type()是函数，dtype是方法）</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 数组中每个元素的字节大小，int32类型字节为4，float64类型字节为8</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span>data<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/01/30/U6oOE2h9xIDlptc.png"></p><pre class="line-numbers language-python"><code class="language-python">ar1 <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">3.0</span><span class="token punctuation">,</span>num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span>ar2 <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">3.0</span><span class="token punctuation">,</span>num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>endpoint <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>ar3 <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">3.0</span><span class="token punctuation">,</span>num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>retstep <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar1<span class="token punctuation">,</span>type<span class="token punctuation">(</span>ar1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar3<span class="token punctuation">,</span>type<span class="token punctuation">(</span>ar3<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/01/30/LrC6B1tSIvkTxmK.png"></p><h3 id="②索引和切片"><a href="#②索引和切片" class="headerlink" title="②索引和切片"></a>②索引和切片</h3><ul><li>核心：基本索引及切片 / 布尔型索引及切片</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npar <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 一维数组索引及切片（类似list）</span>ar <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">,</span> <span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 4*4的数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 切片为下一维度的一个元素，所以是一维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 二次索引，得到一维数组中的一个值</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'数组轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 切片为两个一维数组组成的二维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 切片数组中的第3行第3列--->10</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 切片数组中的1,2行，2、3、4列--->二维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----------------------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 二维数组索引及切片</span>ar <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">,</span> <span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 2*2*2的数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 三维数组的下一个维度的第一个元素--->一个二维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 三维数组的下一个维度的第一个元素下的第一个元素--->一个一维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'数组的轴数为%d'</span><span class="token operator">%</span> ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 三维数组索引及切片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/01/30/ZqM1SrEDaI26NJ4.png"></p><h1 id="二、pandas"><a href="#二、pandas" class="headerlink" title="二、pandas"></a>二、pandas</h1><h2 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><ul><li>Pandas 是一个强大的Python库，专门用于数据操作和分析。它提供了数据结构和数据分析工具，特别是为处理表格数据（类似于电子表格或SQL表）设计的数据结构DataFrame，以及用于处理一维标记数据的Series对象。</li><li>Pandas在处理各种数据源时非常有用，支持从CSV、Excel文件、数据库等读取数据，并且可以方便地进行数据清洗、转换、合并和分析。</li></ul><h2 id="2、代码-1"><a href="#2、代码-1" class="headerlink" title="2、代码"></a>2、代码</h2><h3 id="①对象"><a href="#①对象" class="headerlink" title="①对象"></a>①对象</h3><ul><li>核心：series相比于ndarray，是一个自带索引index的数组 → 一维数组 + 对应索引</li><li>所以当只看series的值的时候，就是一个ndarray</li><li>series和ndarray较相似，索引切片功能差别不大</li><li>series和dict相比，series更像一个有顺序的字典（dict本身不存在顺序），其索引原理与字典相似（一个用key，一个用index）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Series数据结构</span><span class="token comment" spellcheck="true"># Series是带有标签的一维数组，可以保存任何数据类型（整数、字符串、浮点数、Python对象等），轴标签统称为索引</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 导入Numpy，Pandas模块</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Series的索引未必一定是数字，也可以是字母等等</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看数据，数据类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>index<span class="token punctuation">,</span>type<span class="token punctuation">(</span>s<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># index类似于一个生成器，要想输出可以用list()</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>values<span class="token punctuation">,</span>type<span class="token punctuation">(</span>s<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># .index查看series索引，类型为rangeindex</span><span class="token comment" spellcheck="true"># .values查看series值，类型是ndarray</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><img src="https://s2.loli.net/2025/01/30/EKbWYXA2rOwCZt5.png"></p><h3 id="②索引"><a href="#②索引" class="headerlink" title="②索引"></a>②索引</h3><hr><ul><li>位置下标</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 位置下标，类似列表</span>s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>float<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>type<span class="token punctuation">(</span>float<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>位置下标从0开始<br>输出结果为numpy.float格式<br>可以通过float()函数转换为Python float 格式<br>numpy.float与float占用字节不同</em></p><p>输出：<br><img src="https://s2.loli.net/2025/01/30/QyuNeabVf5cz7qr.png"></p><hr><ul><li>标签索引</li></ul><pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>index <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 方法类似下标索引，用[]表示，里面协商相应的index，注意，index是字符串</span>sci <span class="token operator">=</span> s<span class="token punctuation">[</span>list<span class="token punctuation">(</span><span class="token string">'abe'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>sci<span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>sci<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> sci<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>如果需要选择多个标签的值，用[[]]来表示（相当于[]中包含一个列表）<br>多标签索引结果是新的数组  注意：<strong>标签的顺序可以改变！！！</strong></em></p><p>输出：<br><img src="https://s2.loli.net/2025/01/30/9sW2naCxQyVhUBw.png"></p><hr><ul><li>切片索引</li></ul><pre class="line-numbers language-python"><code class="language-python">s1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>s2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'\t'</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 下标</span><span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'\t'</span><span class="token punctuation">,</span>s2<span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#  标签</span><span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'\t'</span><span class="token punctuation">,</span>s2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-------------------------------------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 注意：用index做切片是末端包含</span><span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>下标索引做切片，和列表写法一样</em></p><p>输出：<br><img src="https://s2.loli.net/2025/01/30/lk3D1fsFKTyZ47A.png"></p><hr><ul><li>布尔型索引</li></ul><pre class="line-numbers language-py"><code class="language-py">s = pd.Series(np.random.rand(3)*100)s[4] = None      # 添加一个空值，将空值写成np.NaN也是可以的print(s)bs1 = s > 50bs2 = s.isnull()bs3 = s.notnull()print(bs1,type(bs1),bs1.dtype)print(bs2,type(bs2),bs2.dtype)print(bs3,type(bs3),bs3.dtype)print("-----------------------------------------")# 数组作出判断之后，返回的是有一个布尔值组成的新的数组# .isnull() / .notnull() 方法判断是否为空值（None代表空值，NaN代表有问题的数值，两个都会识别为空值）print(s[s > 50])print(s[bs3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>布尔型索引方法：用[判断条件]来进行表示，其中判断条件可以是一条语句，或者也可以是一个布尔型数组！</em></p><p>输出：<br><img src="https://s2.loli.net/2025/01/30/HS6JrxtFBDbR2Lc.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 生物信息学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习1——Pandas</title>
      <link href="/2025/01/29/ji-qi-xue-xi-1-pandas/"/>
      <url>/2025/01/29/ji-qi-xue-xi-1-pandas/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>Pandas 是 Python 语言的一个扩展程序库，用于数据分析。</li><li>Pandas 名字衍生自术语 “panel data”（面板数据）和 “Python data analysis”（Python 数据分析）。</li><li>Pandas 是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具。</li><li>Pandas 一个强大的分析结构化数据的工具集，基础是 Numpy（提供高性能的矩阵运算）。</li></ul><hr><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li>panel + data + analysis（panel data 面板数据）</li><li>数据处理工具</li></ul><h2 id="Why-pandas？"><a href="#Why-pandas？" class="headerlink" title="- Why pandas？"></a>- Why pandas？</h2><ul><li>便捷的数据处理能力</li><li>读取文件方便</li><li>封装了Matplotlib、Numpy的画图和计算</li></ul><h1 id="二、核心数据结构"><a href="#二、核心数据结构" class="headerlink" title="二、核心数据结构"></a>二、核心数据结构</h1><p><em><strong>具体介绍代码见Python&gt;pandas文件中的==data_structure.ipynb==文件</strong></em></p><ul><li><strong>==dataframe==</strong></li><li>series<br><em>理解：DataFrame是Series的容器</em></li></ul><h2 id="1、DataFrame"><a href="#1、DataFrame" class="headerlink" title="1、DataFrame"></a>1、DataFrame</h2><h3 id="（1）基本"><a href="#（1）基本" class="headerlink" title="（1）基本"></a>（1）基本</h3><ul><li>结构：类似二维数组，有行、列索引</li><li>属性：shape、index、columns、values、T（转置）</li><li>方法：head()、tail()</li></ul><h3 id="（2）索引的设置"><a href="#（2）索引的设置" class="headerlink" title="（2）索引的设置"></a>（2）索引的设置</h3><ul><li>修改行列索引值（只能整体修改）</li><li>重设索引</li><li>设置新索引</li></ul><h3 id="（3）MultiIndex"><a href="#（3）MultiIndex" class="headerlink" title="（3）MultiIndex"></a>（3）MultiIndex</h3><ul><li>MultiIndex是设置了多索引之后的DataFrame，可以存储三维数据</li><li>MultiIndex的属性有names、levels</li></ul><h2 id="2、Series"><a href="#2、Series" class="headerlink" title="2、Series"></a>2、Series</h2><ul><li><p>带索引的一维数组<br><img src="https://s2.loli.net/2025/01/14/oTAGCauzhKpjsRH.png" alt="image.png"></p></li><li><p>属性：index、values</p></li><li><p>方法：创建Series、head()、tail()</p></li></ul><h1 id="三、基本数据操作"><a href="#三、基本数据操作" class="headerlink" title="三、基本数据操作"></a>三、基本数据操作</h1><p><em><strong>具体代码见Python&gt;pandas文件中的==basic_data_operations.ipynb==文件</strong></em></p><h2 id="1、索引操作"><a href="#1、索引操作" class="headerlink" title="1、索引操作"></a>1、索引操作</h2><ul><li>直接索引（必须先列后行）</li><li>按名字索引（loc，先行后列）</li><li>按数字索引（iloc，先行后列）</li><li>组合索引（loc、iloc，数字和名字混用）</li><li>isin()：判断某一行是否存在某个值</li></ul><h2 id="2、赋值操作"><a href="#2、赋值操作" class="headerlink" title="2、赋值操作"></a>2、赋值操作</h2><ul><li>整列修改</li><li>索引到某个值后修改</li></ul><h2 id="3、排序操作"><a href="#3、排序操作" class="headerlink" title="3、排序操作"></a>3、排序操作</h2><ul><li>对内容排序（.sort_values(by=’ ‘, ascending=<strong>True</strong>/False)）</li><li>对索引排序（.sort_index()）<br><em>对于Series来说只有一维，不用考虑按照哪个字段排序</em></li></ul><h2 id="4、运算操作"><a href="#4、运算操作" class="headerlink" title="4、运算操作"></a>4、运算操作</h2><p><em>主要是DataFrame</em></p><ul><li><p>算术运算（add()）</p></li><li><p>逻辑运算</p><ul><li>逻辑运算符（&lt;、&gt;、|、&amp;）</li><li>逻辑运算函数（**query(查找的字符串)**、isin()）</li></ul></li><li><p>统计运算</p><ul><li>统计指标：count、min、max、mean、median、var、std</li><li>describe()：直接得出统计指标<ul><li>效果：<img src="https://s2.loli.net/2025/01/14/gewhsKTdoXjfzYp.png" alt="image.png"></li></ul></li><li>返回索引：idxmin()、idxmax()</li><li>累计统计函数：cumsum()、cummax()、cummin()、cumprod()</li><li><strong>配合画图函数plot()：默认为折线图</strong><ul><li>cumsum()画图效果：<em>（记得先对时间排序再累加）</em><img src="https://s2.loli.net/2025/01/14/63nlHfO1ZALTWgb.png" alt="image.png"></li></ul></li></ul></li><li><p>自定义运算（apply(func, axis= )）</p><ul><li>func：自定义函数</li><li>axis：默认为按列运算axis=0</li></ul></li></ul><h2 id="5、画图操作"><a href="#5、画图操作" class="headerlink" title="5、画图操作"></a>5、画图操作</h2><ul><li>(Series).plot()：默认折线图（见上面运算操作中的统计运算）</li><li>(DataFrame).plot()：参数x、y、kind（图的类型）<ul><li><p>API：<br>  <img src="https://s2.loli.net/2025/01/14/XwVSvbd3mol6BcY.png" alt="image.png"></p></li><li><p>散点图效果：<em>（kind=’scatter’）</em><img src="https://s2.loli.net/2025/01/14/RZU5ELAzhwGgeX6.png" alt="image.png"></p></li></ul></li></ul><h1 id="四、文件读取与存储"><a href="#四、文件读取与存储" class="headerlink" title="四、文件读取与存储"></a>四、文件读取与存储</h1><p><em><strong>具体代码见Python&gt;pandas文件中的==file_reading.ipynb==文件</strong></em></p><ul><li>numpy缺点：读不了字符串</li><li>大部分数据文件pandas都可以读取<br><img src="https://s2.loli.net/2025/01/14/fIjwL14ZiH3k9Wp.png" alt="image.png"><br><em>pandas可读取和储存的文件↑</em></li></ul><h2 id="1、csv文件"><a href="#1、csv文件" class="headerlink" title="1、csv文件"></a>1、csv文件</h2><h3 id="读取："><a href="#读取：" class="headerlink" title="读取："></a>读取：</h3><ul><li>pd.read_csv(路径)<ul><li>参数（可省略）：<ul><li>usecols：只读取这些列</li><li>names：命名列索引</li></ul></li></ul></li></ul><h3 id="存储："><a href="#存储：" class="headerlink" title="存储："></a>存储：</h3><ul><li>(DataFrame).to_csv(路径)<ul><li>参数（可省略）：<ul><li>columns：只保存指定的列，用列表选取</li><li>mode：读写方式，默认”w“重写，“a“追加</li><li>index：默认为True（保留<strong>行</strong>索引），False不保留</li><li>header：默认为True（保留<strong>列</strong>索引），False不保留</li></ul></li></ul></li></ul><h2 id="2、hdf5文件"><a href="#2、hdf5文件" class="headerlink" title="2、hdf5文件"></a>2、hdf5文件</h2><ul><li>二进制文件，不能直接预览</li><li>具有许多优点</li><li>一个键对应一个DataFrame，可以理解成存储三维数据</li></ul><h3 id="读取：-1"><a href="#读取：-1" class="headerlink" title="读取："></a>读取：</h3><ul><li>pd.read_hdf(路径 , key= )：多个键时必须指定key= <ul><li>参数（可省略）：<ul><li>mode：打开文件的模式</li></ul></li></ul></li></ul><h3 id="存储：-1"><a href="#存储：-1" class="headerlink" title="存储："></a>存储：</h3><ul><li>(DataFrame).to_hdf(路径 , key= )：<strong>存储时key必须有</strong></li></ul><h2 id="3、json文件"><a href="#3、json文件" class="headerlink" title="3、json文件"></a>3、json文件</h2><ul><li>前后端交互经常用到</li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ul><li>pd.read_json(路径 , lines= )<ul><li>参数：<ul><li>orient：读取的json文件以什么形式展示，<strong>一般用”records”</strong></li><li>lines：是否按行读取，填bool值，默认为False，<strong>一般需要指定为True</strong></li></ul></li></ul></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>(DataFrame).to_json(路径 , key= )<ul><li>参数：<ul><li>orient：读取的json文件以什么形式展示，<strong>一般用”records”</strong></li><li>lines：是否按行读取，填bool值，默认为False，<strong>一般需要指定为True</strong></li></ul></li></ul></li></ul><h1 id="五、高级处理"><a href="#五、高级处理" class="headerlink" title="五、高级处理"></a>五、高级处理</h1><p><em><strong>具体代码见Python&gt;pandas文件中的==advanced_processing.ipynb==文件</strong></em></p><ul><li>缺失值处理</li><li>数据离散化</li><li>合并</li><li>交叉表与透视表</li><li>分组与聚合</li></ul><h2 id="1、缺失值处理"><a href="#1、缺失值处理" class="headerlink" title="1、缺失值处理"></a>1、缺失值处理</h2><h3 id="（1）How？"><a href="#（1）How？" class="headerlink" title="（1）How？"></a>（1）How？</h3><ul><li>思路：<ol><li>删除含有缺失值的样本</li><li>替换/插补，一般用平均值 / 众数值替换</li></ol></li></ul><h3 id="（2）处理NaN"><a href="#（2）处理NaN" class="headerlink" title="（2）处理NaN"></a>（2）处理NaN</h3><ol><li>判断是否存在NaN（结合np.any/np.all判断，或者直接加any()/all()）<ul><li>pd.isnull(DataFrame)：缺失值的地方返回True</li><li>pd.notnull(DataFrame)：不是缺失值的地方返回True</li></ul></li><li>删除含有缺失值的样本<ul><li>df.dropna(inplace= )：默认按行删除，默认inplace=False不修改原数据，生成新对象<br><strong>或</strong>：</li></ul></li><li>替换/插补<ul><li>平均值插补：df.loc[:, ‘xxx’] = df[‘xxx’].fillna(df[‘xxx’].mean())</li><li>众数值插补：<ol><li>counts = x_pred[feat].value_counts()</li><li>x_pred.loc[:, feat] = x_pred[feat].fillna(counts.idxmax())</li></ol></li></ul></li></ol><h3 id="（3）处理非NaN的缺失值"><a href="#（3）处理非NaN的缺失值" class="headerlink" title="（3）处理非NaN的缺失值"></a>（3）处理非NaN的缺失值</h3><ol><li>替换：符号 -&gt; np.nan<ul><li>df.replace(to_replace=需要替换的东西 , value=np.nan)</li></ul></li><li>处理NaN</li></ol><h2 id="2、数据离散化"><a href="#2、数据离散化" class="headerlink" title="2、数据离散化"></a>2、数据离散化</h2><ul><li><p>用数据表示特征（取代字符串），便于后续运算</p></li><li><p>将连续数据分成多个离散区间，用不同的值代表落在区间<br><img src="https://s2.loli.net/2025/01/18/2R1feDQVIAc9q3t.png" alt="image.png"><br><strong>one-hot编码（独热编码/哑变量）</strong></p></li><li><p>数据离散化为了简化数据结构，让数据之间关系平等<br><em><strong>案例：股票的涨跌幅离散化，见文件</strong></em></p></li></ul><h3 id="如何实现数据离散化？"><a href="#如何实现数据离散化？" class="headerlink" title="如何实现数据离散化？"></a>如何实现数据离散化？</h3><ol><li>分组<ul><li>自动分组：sr = pd.qcut(data , 组数)<ul><li>自动分成等间距的组</li></ul></li><li>自定义分组：sr = pd.cut(data , bins=[区间] )<ul><li>区间列表内只用传各个区间边界值，如：bins = [150, 165, 180, 195] 分成三个区间</li></ul></li></ul></li><li>转换成独热编码（one-hot编码/哑变量）<ul><li>pd.get_dummies(sr , prefix= 前缀 , <strong>dtype=int</strong>)</li></ul></li></ol><h2 id="3、合并"><a href="#3、合并" class="headerlink" title="3、合并"></a>3、合并</h2><h3 id="（1）按方向合并"><a href="#（1）按方向合并" class="headerlink" title="（1）按方向合并"></a>（1）按方向合并</h3><ul><li>pd.concat([data1 , data2] , axis= )：默认axis=0竖直拼接</li></ul><h3 id="（2）按索引合并"><a href="#（2）按索引合并" class="headerlink" title="（2）按索引合并"></a>（2）按索引合并</h3><ul><li>pd.merge(左表 , 右表 , how=”连接方式” , on=[索引])：默认how=”inner”内连接<br><img src="https://s2.loli.net/2025/01/18/lgniweWsYC24JcQ.png" alt="image.png"><br><em><strong>连接方式</strong>，与SQL类似，碰到不共有的键补NaN</em></li></ul><h2 id="4、交叉表与透视表"><a href="#4、交叉表与透视表" class="headerlink" title="4、交叉表与透视表"></a>4、交叉表与透视表</h2><ul><li>探索两个变量直接的关系</li></ul><h3 id="（1）交叉表"><a href="#（1）交叉表" class="headerlink" title="（1）交叉表"></a>（1）交叉表</h3><ul><li>寻找两数据列之间的关系</li><li>pd.crosstab(数据列1 , 数据列2)：得到的是频数分布（先行索引，后列索引）<br><em><strong>pandas日期类型，如date = pd.to_datetime(stock.index)，用date.year/month/week等获取日期信息</strong></em></li></ul><h3 id="（2）透视表"><a href="#（2）透视表" class="headerlink" title="（2）透视表"></a>（2）透视表</h3><ul><li>df.pivot_table([ ] , index=[ ])：直接得出频率</li></ul><h2 id="5、分组与聚合"><a href="#5、分组与聚合" class="headerlink" title="5、分组与聚合"></a>5、分组与聚合</h2><ul><li><p>什么是分组与聚合：<br><img src="https://s2.loli.net/2025/01/19/3MJSqbXhd41pZQi.png" alt="image.png"><br><em>按类别分组，再经过统计函数聚合</em><br><strong>一般同时使用分组与聚合</strong></p></li><li><p>DataFrame方法：</p><ul><li>df.groupby(by=[“分组按照的列”])[“需要聚合的列”].func( )：func( )为聚合的统计函数，分组按照的列可以不止一个，放在列表给出</li><li>例如：col.groupby(by=[‘color’])[‘price1’].max()</li></ul></li><li><p>Series方法：</p><ul><li>df[“需要聚合的列”].groupby(by=df[“分组按照的列”]).func( )</li><li>例如：col[‘price1’].groupby(by=col[‘color’]).max()</li></ul></li></ul><p><em><strong>星巴克零售店铺数据案例：见文件</strong></em></p><h1 id="六、综合案例：电影数据分析"><a href="#六、综合案例：电影数据分析" class="headerlink" title="六、综合案例：电影数据分析"></a>六、综合案例：电影数据分析</h1><p><em><strong>具体代码见Python&gt;pandas文件中的==comprehensive_case.ipynb==文件</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML + CSS</title>
      <link href="/2025/01/27/html-css/"/>
      <url>/2025/01/27/html-css/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><strong>HTML</strong>：HTML的全称为超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，为人们查找，检索信息提供方便。</li><li><strong>CSS</strong>：层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</li></ol><hr><h1 id="1、HTML"><a href="#1、HTML" class="headerlink" title="1、HTML"></a>1、HTML</h1><p>问题求助：利用jsfiddle.net，可以随时修改代码<br>学习、求助：codepen.io<br>测试网页有效：validator.w3.org/#validate_by_input</p><ul><li>具体HTML结构标签看文件夹HTML</li><li>换行符标签：<br>（单标签，也可写成&lt;br&gt;&lt;/br&gt;）</li><li>斜体标签：\&lt;i&gt;&lt;/i&gt;</li><li>水平线标签：\&lt;hr&gt;</li><li>设置网页编码为简体中文：\&lt;meta charset=”gb2313”&gt;</li><li>居中标签：\&lt;center&gt;&lt;/center&gt;</li><li>表格标签</li></ul><h1 id="2、CSS"><a href="#2、CSS" class="headerlink" title="2、CSS"></a>2、CSS</h1><h2 id="1、样式表"><a href="#1、样式表" class="headerlink" title="1、样式表"></a>1、样式表</h2><p><img src="https://s2.loli.net/2025/01/12/3GXh4QwCEibmUYt.png" alt="Pasted image 20240713171319"></p><h2 id="2、选择器"><a href="#2、选择器" class="headerlink" title="2、选择器"></a>2、选择器</h2><ul><li><p>三种选择器：元素、类、ID选择器<br><img src="https://s2.loli.net/2025/01/12/yhCJFfELiQdBAHt.png" alt="Pasted image 20240713171406"></p></li><li><p>组合选择器：<br><img src="https://s2.loli.net/2025/01/12/FZXbAVSkla4QtfD.png" alt="Pasted image 20240713170708"></p></li><li><p>伪类选择器<br><img src="https://s2.loli.net/2025/01/12/2LDdptlVo5g9ca7.png" alt="Pasted image 20240713171653"><br><em>第1、2改变链接的样式，第3、4个改变动态样式，第5个锚定目标</em></p></li></ul><h2 id="3、文本样式设计"><a href="#3、文本样式设计" class="headerlink" title="3、文本样式设计"></a>3、文本样式设计</h2><ul><li>外部样式表<br>标签&lt;link rel=”xxx”  href=”xxx.css”&gt;：链接到外部样式表</li><li>解决冲突：<br>1、声明靠后的优先<br>2、子标签会继承父标签<br>3、特定规则：<br><img src="https://s2.loli.net/2025/01/12/47snQ3fXGgPBHSo.png" alt="Pasted image 20240715205055"><br><em>!important：直接垄断样式</em></li><li>文本样式：（例子）<br>font-family: Arial, Helvetica, sans-serif; ：字体<br>color: #0000ff; ：字体颜色<br>font-style: italic; ：斜体<br>font-weight: bold; ：加粗<br>font-size: 24px; / font-size: 120%; （当前的120%）/ font-size: 2em;（当前的两倍）/ font-size: .5em;（当前的0.5倍）：字体大小<br>text-transform: uppercase; ：全部大写<br>text-align: right; ：靠右对齐</li></ul><h2 id="4、箱体模型和布局"><a href="#4、箱体模型和布局" class="headerlink" title="4、箱体模型和布局"></a>4、箱体模型和布局</h2><ul><li>盒子模型：<br><em>*选择器：强制应用于所有标签</em><br><img src="https://s2.loli.net/2025/01/12/3dbtUZHE2x41STg.png" alt="Pasted image 20240716165827"></li><li>背景属性：<br><img src="https://s2.loli.net/2025/01/12/DtJzCAlrpR9smoY.png" alt="Pasted image 20240716172045"></li><li>浮动定位元素</li><li>绝对定位和相对定位</li></ul><h2 id="5、响应式设计"><a href="#5、响应式设计" class="headerlink" title="5、响应式设计"></a>5、响应式设计</h2><ul><li><p>媒体查询：特定屏幕性质（大小、横竖等）设置特定样式<br><img src="https://s2.loli.net/2025/01/12/gaB7hR8ozW3cL16.png" alt="Pasted image 20240717171141"><br><img src="https://s2.loli.net/2025/01/12/Jd7sFOKHUah4Pgr.png" alt="Pasted image 20240717171656"></p></li><li><p>响应式设计：网站布局适应不同设备</p></li><li><p>响应式框架：12列网格布局<br><img src="https://s2.loli.net/2025/01/12/ntVO5r8I1KZwXyf.png" alt="Pasted image 20240717174332"></p></li></ul><h2 id="6、Twitter-Bootstrap"><a href="#6、Twitter-Bootstrap" class="headerlink" title="6、Twitter Bootstrap"></a>6、Twitter Bootstrap</h2><ul><li><p>定义：<br><img src="https://s2.loli.net/2025/01/12/qvsF5wlIz7RVoGn.png" alt="Pasted image 20240720203218"></p></li><li><p>缺点：<br><img src="https://s2.loli.net/2025/01/12/hmbRu79CWs54SZG.png" alt="Pasted image 20240720203157"></p></li><li><p>网格系统：<br><img src="https://s2.loli.net/2025/01/12/ONGKFD5r18TgzVk.png" alt="Pasted image 20240720211159"><br><em>↑代码示例</em><br><img src="https://s2.loli.net/2025/01/12/EbsNAIXFPWGumdY.png" alt="Pasted image 20240720210715"><br><em>↑行的运用</em><br><img src="https://s2.loli.net/2025/01/12/rCFhpXmtnaIJ4s1.png" alt="Pasted image 20240720212805"><br><em>↑列的运用</em></p></li></ul><h1 id="3、实战"><a href="#3、实战" class="headerlink" title="3、实战"></a>3、实战</h1><ul><li>基本原则（制作网页前与客户达成一致）：<br><img src="https://s2.loli.net/2025/01/12/9AlQK1sJ8uIv2kb.png" alt="Pasted image 20240721230147"></li><li>先设计版面，再编写程序，然后审核、修改</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《文明之旅》1000-1010年</title>
      <link href="/2025/01/26/wen-ming-zhi-lu-1000-1010-nian/"/>
      <url>/2025/01/26/wen-ming-zhi-lu-1000-1010-nian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一档聚焦中国历史，计划持续二十年制作播出的视频节目，也是一个超长期的文化工程。它将传承《资治通鉴》的中国编年史传统，从公元1000年开讲，一直讲到1912年，每一期节目聚焦于中国历史上的一年。上下913期节目，前后20年的时光，将陪伴和影响不止一代人。</p><hr><h2 id="1000"><a href="#1000" class="headerlink" title="1000"></a>1000</h2><ul><li>宋代走出五代阴影，士大夫崛起。</li></ul><h2 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h2><ul><li>四川由来，瓦解比土崩更难重建，地方军阀削弱。</li></ul><h2 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h2><ul><li>科举改革，对大臣互相勾结的削弱，他荐制变为自荐制。</li></ul><h2 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h2><ul><li>李沆，建议都包含动机，你眼里的问题是别人的解决方案。真正的保守主义，反对以法国大革命为例的、以理性为核心的自由主义，反对对社会的彻底破坏与重建，主张从基层寻找进步的方向，不断试错与纠正，达到逐步进步的目的。</li></ul><h2 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h2><ul><li>皇帝亲征，防守战第几个，将国家经济资源和技术资源转化为战斗力。</li></ul><h2 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h2><ul><li>澶渊之盟签订，有利于大宋，可以算账的战争，双方更多约束羁绊。战争爆发只有一种原因，一方对双方实力错误评估，信息差。</li></ul><h2 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h2><ul><li>景德镇，农耕文明中的工业文明火种，农业与工业的区别，特别是思想观念上，出现了截然不同的人生道路，考取功名不是唯一生存形式。（北京 模范空间）</li></ul><h2 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h2><ul><li>辽朝建第四都城（中京），农耕文明与游牧文明的民族大融合是必须解决的问题。管理区别，中原民族收税（易），草原民族收买（难）。二元王朝辽朝南北院，两种制度管理。辽朝皇帝四时捺钵，与各领地沟通和交易。</li></ul><h2 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h2><ul><li>天书封禅，宋真宗大搞迷信活动（真宗是历史上第六位也是最后一位封禅皇帝）。主流解释是奸臣王钦若推荐真宗封禅，新解释认为是太平盛世，民心所向。但是神道设教的谎言受人唾弃批评。迷信的社会后果：1.传播范围广，低成本高收益；2.很强的网络性，受身边人影响；3.信息失真，民众跟风，坏人搭便车牟利，后果随时间越来越大。（海外汉学传统）</li></ul><h2 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h2><ul><li>建道观（玉清昭应宫）供奉天书，耗财耗力，用军队建，赏赐丰厚，人们乐意参与。宋真宗模仿唐玄宗，要确保赵家正统性，证明现在是太平盛世。皇帝停不下来迷信活动：个人因素认知失调（当你发现事实和认知不符时，必然会产生一个幻觉来解释事实）。社会因素身边人因自身利益推动，观念变成事实不好收手。</li></ul><h2 id="1010"><a href="#1010" class="headerlink" title="1010"></a>1010</h2><ul><li>宋仁宗出生。辽朝打高丽，因为陆地大国有安全困境（不是朋友的人互相猜忌，导致所有人都紧张备战，大战一触即发，除非互相充满善意）。边疆问题十分敏感（明确界限，邻国问题）。高丽打不服，因为文化上蔑视辽朝，仰慕宋朝。宋和辽都搞不定周边小国，因为都有自己的文化认同（唐朝遗留）。唐朝管理边疆时采用羁縻制度（极大自主权，但受中央管理），首领世子进宫，皇帝赐姓李，少数民族从中学习了唐朝制度文化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《文明之旅》 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test my site</title>
      <link href="/2025/01/23/test-my-site/"/>
      <url>/2025/01/23/test-my-site/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>测试我的网站。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/23/hello-world/"/>
      <url>/2025/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
